<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Information dash board</title>
    <style>
        :root {
            /* Light Theme */
            --primary-color: #1a62e8;
            --secondary-color: #f1f3f4;
            --hover-color: #e8f0fe;
            --border-color: #dadce0;
            --text-color: #202124;
            --text-secondary-color: #5f6368;
            --white-color: #ffffff;
            --success-color: #0f9d58;
            --warning-color: #f4b400;
            --danger-color: #d93025;
            --priority-low-color: #1e88e5;
            --priority-medium-color: var(--warning-color);
            --priority-high-color: var(--danger-color);
            --font-family: 'Roboto', 'Noto Sans KR', sans-serif;
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            --column-bg: #ffffff;
            --body-bg: #f8f9fa;
            --header-bg: var(--primary-color);
            --input-bg: #ffffff;
            --ai-primary: #6e00ff;
            --ai-accent: #00f7ff;
            --placeholder-bg: rgba(26, 98, 232, 0.1);
            --placeholder-border: var(--primary-color);

            /* Dark Theme Variables (will be set via JS) */
            --dark-primary-color: #8ab4f8;
            --dark-secondary-color: #5f6368;
            --dark-hover-color: #3c4043;
            --dark-border-color: #5f6368;
            --dark-text-color: #e8eaed;
            --dark-text-secondary-color: #9aa0a6;
            --dark-white-color: #202124;
            --dark-success-color: #81c995;
            --dark-warning-color: #fdd663;
            --dark-danger-color: #f28b82;
            --dark-priority-low-color: #8ab4f8;
            --dark-priority-medium-color: var(--dark-warning-color);
            --dark-priority-high-color: var(--dark-danger-color);
            --dark-column-bg: #292a2d;
            --dark-body-bg: #202124;
            --dark-header-bg: #1c3aa9;
            --dark-input-bg: #35363a;
            --dark-ai-primary: #8a63ff;
            --dark-ai-accent: #00f7ff;
            --dark-placeholder-bg: rgba(138, 180, 248, 0.1);
            --dark-placeholder-border: var(--dark-primary-color);
        }

        /* Dark Mode */
        .theme-dark {
            --primary-color: var(--dark-primary-color);
            --secondary-color: var(--dark-secondary-color);
            --hover-color: var(--dark-hover-color);
            --border-color: var(--dark-border-color);
            --text-color: var(--dark-text-color);
            --text-secondary-color: var(--dark-text-secondary-color);
            --white-color: var(--dark-white-color);
            --success-color: var(--dark-success-color);
            --warning-color: var(--dark-warning-color);
            --danger-color: var(--dark-danger-color);
            --priority-low-color: var(--dark-priority-low-color);
            --priority-medium-color: var(--dark-priority-medium-color);
            --priority-high-color: var(--dark-priority-high-color);
            --column-bg: var(--dark-column-bg);
            --body-bg: var(--dark-body-bg);
            --header-bg: var(--dark-header-bg);
            --input-bg: var(--dark-input-bg);
            --ai-primary: var(--dark-ai-primary);
            --ai-accent: var(--dark-ai-accent);
            --placeholder-bg: var(--dark-placeholder-bg);
            --placeholder-border: var(--dark-placeholder-border);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: var(--font-family); }
        body { background-color: var(--body-bg); color: var(--text-color); font-size: 14px; line-height: 1.5; transition: background-color 0.3s ease, color 0.3s ease; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }

        /* Header */
        .header { background-color: var(--header-bg); color: var(--white-color); padding: 16px 24px; display: flex; justify-content: space-between; align-items: center; border-radius: var(--border-radius-md) var(--border-radius-md) 0 0; margin-bottom: 20px; box-shadow: var(--box-shadow); position: relative; }
        .header__logo { font-size: 22px; font-weight: 700; }
        .header__user-area { display: flex; align-items: center; gap: 16px; }
        .header__user-name { font-weight: 500; }
        .header__theme-toggle { background: none; border: none; color: var(--white-color); cursor: pointer; font-size: 20px; padding: 4px; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s ease; }
        .header__theme-toggle:hover { background-color: rgba(255, 255, 255, 0.1); }

        /* Tabs */
        .tabs { display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap; }
        .tabs__tab { padding: 8px 16px; background-color: var(--secondary-color); border: 1px solid transparent; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; font-weight: 500; }
        .tabs__tab--active { background-color: var(--hover-color); color: var(--primary-color); border-color: var(--primary-color); }
        .tabs__tab:hover:not(.tabs__tab--active) { background-color: var(--hover-color); }

        /* Search */
        .search { display: flex; margin-bottom: 20px; position: relative; }
        .search__input { flex-grow: 1; padding: 10px 16px 10px 40px; border: 1px solid var(--border-color); border-radius: 24px; font-size: 14px; transition: all 0.2s ease; background-color: var(--input-bg); color: var(--text-color); }
        .search__input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(26, 98, 232, 0.2); }
        .search__icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text-secondary-color); }

        /* AI Controls */
        .ai-controls { display: flex; gap: 10px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .ai-model-selector { padding: 8px 12px; background-color: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); cursor: pointer; min-width: 180px; font-size: 13px; }
        .ai-model-selector:disabled { cursor: not-allowed; opacity: 0.6; }
        .ai-btn { padding: 8px 16px; background-color: var(--ai-primary); color: white; border: none; border-radius: var(--border-radius-md); cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 6px; font-size: 13px; }
        .ai-btn:hover { opacity: 0.9; }
        .ai-btn:disabled { background-color: var(--secondary-color); color: var(--text-secondary-color); cursor: not-allowed; opacity: 0.7; }
        .ai-btn--secondary { background-color: var(--secondary-color); color: var(--text-color); }
        .ai-btn--secondary:hover { background-color: var(--hover-color); }

        /* Board */
        .board { display: grid; grid-template-columns: repeat(5, 1fr); gap: 16px; }

        /* Column */
        .column { background-color: var(--column-bg); border-radius: var(--border-radius-md); box-shadow: var(--box-shadow); display: flex; flex-direction: column; overflow: hidden; transition: transform 0.2s ease; }
        .column:hover { transform: translateY(-2px); }
        .column__header { padding: 12px 16px; background-color: var(--secondary-color); font-weight: 600; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); }
        .column__title-area { display: flex; align-items: center; gap: 8px; flex-grow: 1; margin-right: 8px; min-width: 0; /* Prevent overflow */ }
        .column__title { cursor: pointer; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .column__title-input { font-weight: 600; padding: 2px 4px; border: 1px solid var(--primary-color); border-radius: var(--border-radius-sm); width: 100%; background-color: var(--input-bg); color: var(--text-color); font-size: 14px; line-height: 1.5; }
        .column__counter { font-size: 12px; background-color: var(--primary-color); color: white; padding: 2px 6px; border-radius: 10px; margin-left: 4px; flex-shrink: 0; }
        .column__actions { display: flex; align-items: center; gap: 4px; flex-shrink: 0; }

        /* Column Content */
        .column__content { padding: 16px; flex-grow: 1; min-height: 200px; max-height: 65vh; overflow-y: auto; background-color: var(--column-bg); transition: background-color 0.2s ease; position: relative; /* For placeholder positioning */ }
        .column__content--drag-over { background-color: var(--hover-color); } /* Remove outline for placeholder */

        /* Task Placeholder */
        .task--placeholder {
            background-color: var(--placeholder-bg);
            border: 1px dashed var(--placeholder-border);
            border-radius: var(--border-radius-md);
            margin-bottom: 10px;
            height: 50px; /* Adjust height as needed */
            transition: height 0.1s ease;
        }

        .column__quick-add { padding: 0 16px 16px; display: none; }
        .column__quick-add--visible { display: block; }
        .column__quick-add-input { width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); font-size: 14px; background-color: var(--input-bg); color: var(--text-color); }
        .column__quick-add-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(26, 98, 232, 0.2); }

        /* Action Button */
        .action-btn { background: none; border: none; cursor: pointer; color: var(--text-secondary-color); padding: 4px; border-radius: 50%; width: 28px; height: 28px; display: inline-flex; justify-content: center; align-items: center; transition: all 0.2s ease; }
        .action-btn:hover { background-color: var(--hover-color); color: var(--primary-color); }
        .action-btn--edit { font-size: 14px; }
        .action-btn--add { font-size: 20px; font-weight: bold; }
        .action-btn--menu { font-size: 18px; font-weight: bold; }

        /* Task */
        .task { background-color: var(--column-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 10px 12px; margin-bottom: 10px; cursor: grab; transition: all 0.2s ease, opacity 0s; /* opacity transition off for dragging */ position: relative; display: flex; align-items: flex-start; gap: 8px; border-left: 4px solid transparent; }
        .task--dragging { opacity: 0.5; cursor: grabbing; background-color: var(--hover-color); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); z-index: 10; }
        .task:hover { box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); border-color: var(--border-color); }
        .task--priority-low { border-left-color: var(--priority-low-color); }
        .task--priority-medium { border-left-color: var(--priority-medium-color); }
        .task--priority-high { border-left-color: var(--priority-high-color); }
        .task__checkbox { margin-top: 2px; flex-shrink: 0; cursor: pointer; accent-color: var(--primary-color); }
        .task__content { flex-grow: 1; overflow: hidden; }
        .task__title { font-weight: 500; margin-bottom: 4px; cursor: pointer; word-break: break-word; }
        .task__title--completed { text-decoration: line-through; color: var(--text-secondary-color); font-weight: 400; }
        .task__meta { display: flex; justify-content: space-between; font-size: 12px; color: var(--text-secondary-color); gap: 8px; flex-wrap: wrap; }
        .task__meta-item { white-space: nowrap; display: flex; align-items: center; gap: 4px; }
        .task__due-date--overdue { color: var(--danger-color); font-weight: 500; }
        .task__due-date--today { color: var(--success-color); font-weight: 500; }
        .task__due-date--tomorrow { color: var(--priority-low-color); font-weight: 500; }
        .task__tags { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; }
        .task__tag { font-size: 10px; padding: 2px 6px; border-radius: 10px; background-color: var(--secondary-color); color: var(--text-secondary-color); }
        .task__delete-btn { position: absolute; top: 6px; right: 6px; background: none; border: none; font-size: 18px; line-height: 1; cursor: pointer; color: var(--text-secondary-color); padding: 2px; border-radius: var(--border-radius-sm); transition: all 0.2s ease; }
        .task__delete-btn:hover { color: var(--danger-color); background-color: var(--hover-color); }

        /* Modal */
        .modal { display: none; /* Start hidden */ position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center; z-index: 1000; padding: 20px; opacity: 0; transition: opacity 0.3s ease; /* Only opacity transition */ }
        .modal.visible { display: flex; /* Show when visible class added */ }
        .modal--visible { opacity: 1; } /* Trigger opacity transition */
        .modal__content { background-color: var(--column-bg); padding: 24px; border-radius: var(--border-radius-md); width: 100%; max-width: 500px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); max-height: 90vh; overflow-y: auto; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal--visible .modal__content { transform: scale(1); }
        .modal__header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .modal__title { font-size: 18px; font-weight: 600; }
        .modal__close { background: none; border: none; font-size: 24px; font-weight: bold; line-height: 1; cursor: pointer; color: var(--text-secondary-color); padding: 4px; transition: color 0.2s ease; }
        .modal__close:hover { color: var(--text-color); }

        /* AI Interface */
        .ai-interface { position: fixed; bottom: -100%; /* Start fully hidden */ left: 0; right: 0; background: rgba(10, 10, 30, 0.95); border-top: 1px solid var(--ai-primary); padding: 1.5rem; transition: bottom 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); z-index: 100; max-width: 800px; margin: 0 auto; border-radius: 12px 12px 0 0; box-shadow: 0 -5px 20px rgba(0,0,0,0.3); color: var(--dark-text-color); /* AI interface always dark? */ }
        .ai-interface.active { bottom: 0; }
        .ai-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .ai-title { font-weight: 600; color: var(--ai-accent); }
        .ai-close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary-color); cursor: pointer; padding: 5px; line-height: 1; }
        .ai-close-btn:hover { color: var(--ai-accent); }
        .ai-input-container { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
        #aiPrompt { flex: 1; background: transparent; border: 1px solid rgba(110, 0, 255, 0.5); border-radius: 20px; padding: 0.8rem 1rem; color: white; outline: none; font-size: 14px; }
        #aiPrompt::placeholder { color: rgba(255,255,255,0.4); }
        #executeAI { background: var(--ai-primary); border: none; border-radius: 20px; padding: 0 1.5rem; color: white; cursor: pointer; transition: all 0.2s ease; font-size: 14px; }
        #executeAI:hover:not(:disabled) { background: #5a00cc; }
        #executeAI:disabled { background: #555; cursor: not-allowed; }
        .ai-suggestions { display: flex; gap: 0.5rem; overflow-x: auto; padding-bottom: 0.5rem; margin-bottom: 1rem; }
        .ai-suggestion { background: rgba(110, 0, 255, 0.2); border-radius: 20px; padding: 0.4rem 0.8rem; font-size: 0.8rem; white-space: nowrap; cursor: pointer; transition: all 0.2s ease; color: #eee; }
        .ai-suggestion:hover { background: rgba(110, 0, 255, 0.4); }
        .ai-response { max-height: 200px; overflow-y: auto; padding: 0.8rem; background: rgba(0,0,0,0.2); border-radius: 8px; margin-top: 1rem; font-size: 13px; line-height: 1.6; color: #eee; }
        .ai-response div { margin-bottom: 0.5rem; }
        .ai-thinking { color: var(--ai-accent); font-style: italic; }
        .ai-error { color: var(--dark-danger-color); font-weight: bold; }
        .ai-success { color: var(--dark-success-color); }
        .ai-response-text { white-space: pre-wrap; } /* Preserve line breaks from AI */

        /* Form */
        .form-group { margin-bottom: 16px; }
        .form-group__label { display: block; margin-bottom: 6px; font-weight: 500; font-size: 13px; }
        .form-group__input, .form-group__select, .form-group__textarea { width: 100%; padding: 10px 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); font-size: 14px; transition: all 0.2s ease; background-color: var(--input-bg); color: var(--text-color); }
        .form-group__input:focus, .form-group__select:focus, .form-group__textarea:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(26, 98, 232, 0.2); }
        .form-group__textarea { min-height: 80px; resize: vertical; }
        .form-group__tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .form-group__tag { display: inline-flex; align-items: center; font-size: 12px; padding: 4px 8px; background-color: var(--secondary-color); border-radius: var(--border-radius-sm); gap: 4px; color: var(--text-color); }
        .form-group__tag-remove { background: none; border: none; cursor: pointer; color: var(--text-secondary-color); font-size: 12px; padding: 0; line-height: 1; }
        .form-group__tag-remove:hover { color: var(--danger-color); }
        .form-group__tag-input { flex-grow: 1; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); font-size: 14px; background-color: var(--input-bg); color: var(--text-color); }
        .form-group__tag-input:focus { outline: none; border-color: var(--primary-color); }

        /* Form Actions */
        .form-actions { display: flex; justify-content: flex-end; gap: 12px; margin-top: 24px; }

        /* Button */
        .btn { padding: 10px 16px; border-radius: var(--border-radius-sm); cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s ease; border: 1px solid transparent; line-height: 1.4; }
        .btn--primary { background-color: var(--primary-color); color: var(--white-color); border-color: var(--primary-color); }
        .btn--primary:hover { background-color: #185abc; border-color: #185abc; }
        .btn--secondary { background-color: var(--column-bg); color: var(--text-color); border: 1px solid var(--border-color); }
        .btn--secondary:hover { background-color: var(--secondary-color); border-color: var(--border-color); }

        /* Menu */
        .menu { position: absolute; background-color: var(--column-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); z-index: 1001; padding: 4px 0; min-width: 180px; opacity: 0; transform: translateY(-10px) scale(0.95); transform-origin: top left; transition: opacity 0.2s ease, transform 0.2s ease; }
        .menu--visible { opacity: 1; transform: translateY(0) scale(1); }
        .menu__item { padding: 8px 16px; cursor: pointer; transition: background-color 0.2s ease; font-size: 14px; color: var(--text-color); white-space: nowrap; }
        .menu__item:hover { background-color: var(--hover-color); }
        .menu__separator { height: 1px; background-color: var(--border-color); margin: 4px 0; }

        /* Empty State */
        .empty-state { text-align: center; padding: 20px; color: var(--text-secondary-color); font-size: 14px; }

        /* Responsive */
        @media (max-width: 1200px) { .board { grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); } }
        @media (max-width: 768px) {
            .board { grid-template-columns: 1fr; }
            .header { padding: 12px 16px; border-radius: 0; }
            .container { padding: 10px; }
            .modal__content { max-width: 95%; }
            .ai-interface { max-width: 100%; padding: 1rem; border-radius: 8px 8px 0 0; }
            .ai-controls { gap: 8px; }
            .ai-btn, .ai-model-selector { font-size: 12px; padding: 6px 10px; }
        }

        /* 탭 콘텐츠 관련 스타일 */
        .tab-contents {
            width: 100%;
            margin-bottom: 20px;
        }
        .tab-content {
            display: none;
            width: 100%;
        }
        .tab-content--active {
            display: block;
        }

        /* PGM 변경 내역 페이지 스타일 */
        .history-container {
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 20px;
            height: calc(80vh - 180px);
            min-height: 500px;
        }

        .history-column, .history-detail {
            background-color: var(--column-bg);
            border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .history-header, .history-detail__header {
            padding: 16px;
            background-color: var(--secondary-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-header h2, .history-detail__header h2 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .history-actions, .history-detail__actions {
            display: flex;
            gap: 8px;
        }

        .history-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .history-item {
            padding: 12px;
            border-radius: var(--border-radius-sm);
            margin-bottom: 8px;
            cursor: pointer;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .history-item:hover {
            background-color: var(--hover-color);
        }

        .history-item--selected {
            background-color: var(--hover-color);
            border-color: var(--primary-color);
            border-left: 3px solid var(--primary-color);
        }

        .history-item__title {
            font-weight: 500;
            margin-bottom: 5px;
        }

        .history-item__meta {
            font-size: 12px;
            color: var(--text-secondary-color);
            display: flex;
            justify-content: space-between;
        }

        .history-detail__content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .history-detail__content h3 {
            font-size: 20px;
            font-weight: 600;
            margin: 0 0 16px 0;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .history-detail__info {
            background-color: var(--secondary-color);
            padding: 12px;
            border-radius: var(--border-radius-sm);
            margin-bottom: 20px;
        }

        .history-detail__info p {
            margin: 6px 0;
        }

        .history-detail__description h4 {
            font-size: 16px;
            font-weight: 600;
            margin: 20px 0 10px 0;
        }

        .history-detail__description p, .history-detail__description ul {
            margin: 12px 0;
            line-height: 1.6;
        }

        .history-detail__description ul {
            padding-left: 20px;
        }

        /* 반응형 조정 */
        @media (max-width: 992px) {
            .history-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            .history-column {
                max-height: 300px;
            }
        }

        /* Animations */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.3s ease forwards; }

        /* --- 새로운 PGM History 컬럼 구조 스타일 --- */
        .main-columns-container {
            display: flex; /* 큰 컬럼들을 가로로 배치 */
            gap: 20px; /* 큰 컬럼 사이 간격 */
            width: 100%;
            /* 필요하다면 높이 제한 추가: 예시 */
            /* min-height: calc(80vh - 180px); */
            /* max-height: 70vh; */
        }

        .main-column {
            flex: 1; /* 각 큰 컬럼이 동일한 너비를 가지도록 설정 */
            background-color: var(--column-bg);
            border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow);
            padding: 16px;
            display: flex; /* 내부 요소(제목, 서브컬럼 컨테이너)를 세로로 배치 */
            flex-direction: column;
            overflow: hidden; /* 내용 넘칠 경우 처리 (필요시 조정) */
        }

        .main-column-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0 0 16px 0; /* 아래쪽 여백 */
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
            text-align: center; /* 제목 가운데 정렬 (선택적) */
            flex-shrink: 0; /* 제목 영역은 줄어들지 않도록 */
        }

        .sub-columns-container {
            display: flex; /* 서브 컬럼들을 가로로 배치 */
            gap: 10px; /* 서브 컬럼 사이 간격 */
            flex-grow: 1; /* 남은 세로 공간을 채우도록 설정 */
            min-height: 0; /* flex 아이템 내부 스크롤 위해 필요 */
        }

        .sub-column {
            flex: 1; /* 각 서브 컬럼이 동일한 너비를 가지도록 설정 */
            background-color: var(--secondary-color); /* 서브 컬럼 배경색 구분 (선택적) */
            border-radius: var(--border-radius-sm);
            padding: 12px;
            border: 1px solid var(--border-color);
            display: flex; /* 내부 요소(제목, 내용)를 세로로 배치 */
            flex-direction: column;
            overflow: hidden; /* 내부 스크롤 위해 */
        }

        .sub-column-title {
            font-size: 14px;
            font-weight: 600;
            margin: 0 0 10px 0; /* 아래쪽 여백 */
            text-align: center; /* 제목 가운데 정렬 (선택적) */
            flex-shrink: 0; /* 제목 영역 줄어들지 않도록 */
            padding-bottom: 8px;
            border-bottom: 1px dashed var(--border-color); /* 구분선 (선택적) */
        }

        .sub-column-content {
            flex-grow: 1; /* 남은 세로 공간을 채우도록 */
            overflow-y: auto; /* 내용이 많으면 세로 스크롤 생성 */
            padding: 5px; /* 내용 영역 패딩 (선택적) */
        }

        /* 반응형 조정 (예시: 화면 너비 992px 이하일 때) */
        @media (max-width: 992px) {
            .main-columns-container {
                flex-direction: column; /* 큰 컬럼들을 세로로 쌓음 */
            }
            .sub-columns-container {
                 /* 서브 컬럼이 너무 작아지면 세로로 쌓을 수도 있음 (선택적) */
                /* flex-direction: column; */
            }
        }
        /* --- // 새로운 PGM History 컬럼 구조 스타일 --- */
        /* --- 서브 컬럼 헤더 및 추가 버튼 스타일 --- */
        .sub-column-header {
            display: flex; /* 제목과 버튼을 가로로 배치 */
            justify-content: space-between; /* 제목은 왼쪽, 버튼은 오른쪽으로 */
            align-items: center; /* 세로 중앙 정렬 */
            margin-bottom: 10px; /* 아래 내용과의 간격 */
            padding-bottom: 8px; /* 아래 구분선과의 간격 */
            border-bottom: 1px dashed var(--border-color); /* 구분선 */
        }

        /* 서브 컬럼 제목 스타일 조정 (헤더 div 안으로 이동하면서 기존 스타일 일부 제거/수정) */
        .sub-column-title {
            margin: 0; /* 기본 마진 제거 */
            padding: 0; /* 기본 패딩 제거 */
            border: none; /* 기본 테두리 제거 */
            /* font-size, font-weight는 유지 */
        }

        /* 서브 컬럼 추가 버튼 스타일 (기존 action-btn 스타일 활용) */
        .sub-column-add-btn {
            /* 필요하다면 크기나 패딩을 미세 조정할 수 있습니다. */
            padding: 2px;
            width: 24px;
            height: 24px;
            font-size: 18px;
            flex-shrink: 0; /* 버튼 크기가 줄어들지 않도록 함 */
        }
        /* --- // 서브 컬럼 헤더 및 추가 버튼 스타일 --- */

    </style>
</head>
<body>
    <header class="header">
        <div class="header__logo">인폼 현황판</div>
        <div class="header__user-area">
            <div class="header__user-name">인폼</div>
            <button class="header__theme-toggle" aria-label="테마 전환 (라이트/다크)">🌓</button>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <div class="tabs__tab tabs__tab--active">업무 대시보드</div>
            <div class="tabs__tab">PGM Update history</div>
            <div class="tabs__tab">통계</div>
            <div class="tabs__tab">설정</div>
        </div>

        <div class="search">
            <span class="search__icon">🔍</span>
            <input type="text" id="searchInput" class="search__input" placeholder="업무 검색 (제목, 설명, 담당자, 태그)">
        </div>

        <div class="ai-controls">
            <select id="aiModelSelector" class="ai-model-selector" aria-label="AI 모델 선택">
                <option value="">AI 모델 로딩 중...</option>
            </select>
            <button id="toggleAI" class="ai-btn" aria-label="AI 도우미 열기/닫기">
                <span>🤖</span> AI 도우미
            </button>
            <!--<button id="aiOrganize" class="ai-btn ai-btn--secondary" aria-label="AI로 업무 정리 실행">
                <span>🧠</span> AI로 업무 정리
            </button>-->
        </div>

                <!-- 탭 콘텐츠 컨테이너 -->
                <div class="tab-contents">
                    <!-- 업무 대시보드 탭 콘텐츠 (기본으로 표시) -->
                    <div class="tab-content tab-content--active" id="dashboard-content">
                    <!-- 이 영역은 비워둡니다. 기존 board가 여기 표시될 것입니다 -->
                    </div>
                    
        <!-- PGM Update history 탭 콘텐츠 (버튼 추가) -->
        <div class="tab-content" id="pgm-history-content">
            <!-- 두 개의 큰 컬럼을 감싸는 컨테이너 -->
            <div class="main-columns-container">

                <!-- AVI 컬럼 -->
                <div class="main-column AVI-column">
                    <h2 class="main-column-title">AVI</h2>
                    <!-- AVI 하위 컬럼 컨테이너 -->
                    <div class="sub-columns-container">
                        <!-- Red 서브 컬럼 -->
                        <div class="sub-column red-sub-column">
                            <!-- 제목과 추가 버튼을 묶는 헤더 div -->
                            <div class="sub-column-header">
                                <h3 class="sub-column-title">Main PGM</h3>
                                <button class="action-btn action-btn--add sub-column-add-btn" data-column-target="AVI-red" aria-label="Red 컬럼에 항목 추가">+</button>
                            </div>
                            <div class="sub-column-content" id="AVI-red-content">
                                <!-- AVI-Red 컬럼 내용이 동적으로 채워질 영역 -->
                            </div>
                        </div>
                        <!-- Yellow 서브 컬럼 -->
                        <div class="sub-column yellow-sub-column">
                            <!-- 제목과 추가 버튼을 묶는 헤더 div -->
                            <div class="sub-column-header">
                                <h3 class="sub-column-title">Vision PGM</h3>
                                <button class="action-btn action-btn--add sub-column-add-btn" data-column-target="AVI-yellow" aria-label="Yellow 컬럼에 항목 추가">+</button>
                            </div>
                            <div class="sub-column-content" id="AVI-yellow-content">
                                <!-- AVI-Yellow 컬럼 내용이 동적으로 채워질 영역 -->
                            </div>
                        </div>
                    </div>
                </div>
                <!-- // AVI 컬럼 -->

                <!-- ATTACH 컬럼 -->
                <div class="main-column ATTACH-column">
                    <h2 class="main-column-title">ATTACH</h2>
                    <!-- ATTACH 하위 컬럼 컨테이너 -->
                    <div class="sub-columns-container">
                        <!-- Black 서브 컬럼 -->
                        <div class="sub-column black-sub-column">
                            <!-- 제목과 추가 버튼을 묶는 헤더 div -->
                            <div class="sub-column-header">
                                <h3 class="sub-column-title">Main PGM</h3>
                                <button class="action-btn action-btn--add sub-column-add-btn" data-column-target="ATTACH-black" aria-label="Black 컬럼에 항목 추가">+</button>
                            </div>
                            <div class="sub-column-content" id="ATTACH-black-content">
                                <!-- ATTACH-Black 컬럼 내용이 동적으로 채워질 영역 -->
                            </div>
                        </div>
                        <!-- Pink 서브 컬럼 -->
                        <div class="sub-column pink-sub-column">
                            <!-- 제목과 추가 버튼을 묶는 헤더 div -->
                            <div class="sub-column-header">
                                <h3 class="sub-column-title">Vision PGM</h3>
                                <button class="action-btn action-btn--add sub-column-add-btn" data-column-target="ATTACH-pink" aria-label="pink 컬럼에 항목 추가">+</button>
                            </div>
                            <div class="sub-column-content" id="ATTACH-pink-content">
                                <!-- ATTACH-Pink 컬럼 내용이 동적으로 채워질 영역 -->
                            </div>
                        </div>
                    </div>
                </div>
                <!-- // ATTACH 컬럼 -->

            </div>
        </div>
        <!-- // PGM Update history 탭 콘텐츠 -->
            
            <!-- 통계 탭 콘텐츠 -->
            <div class="tab-content" id="statistics-content">
            <h2>통계 콘텐츠 영역</h2>
            <p>통계 기능이 아직 구현되지 않았습니다.</p>
            </div>
            
            <!-- 설정 탭 콘텐츠 -->
            <div class="tab-content" id="settings-content">
            <h2>설정 콘텐츠 영역</h2>
            <p>설정 기능이 아직 구현되지 않았습니다.</p>
            </div>
        </div>

        <div class="board" id="board">
            <!-- Columns will be populated dynamically -->
        </div>

        <!-- Add/Edit Task Modal -->
        <div id="taskModal" class="modal" role="dialog" aria-labelledby="modalTitle" aria-hidden="true">
            <div class="modal__content">
                <div class="modal__header">
                    <div id="modalTitle" class="modal__title">새 업무 추가</div>
                    <button class="modal__close" aria-label="모달 닫기" onclick="app.closeModal()">×</button>
                </div>
                <form id="taskForm">
                    <input type="hidden" id="taskId" name="taskId">
                    <input type="hidden" id="columnId" name="columnId">
                    <div class="form-group">
                        <label for="taskTitle" class="form-group__label">업무명 <span aria-hidden="true">*</span></label>
                        <input type="text" id="taskTitle" name="taskTitle" class="form-group__input" required aria-required="true">
                    </div>
                    <div class="form-group">
                        <label for="taskDescription" class="form-group__label">설명</label>
                        <textarea id="taskDescription" name="taskDescription" class="form-group__textarea"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="taskDueDate" class="form-group__label">마감일</label>
                        <input type="date" id="taskDueDate" name="taskDueDate" class="form-group__input">
                    </div>
                    <div class="form-group">
                        <label for="taskAssignees" class="form-group__label">담당자</label>
                        <input type="text" id="taskAssignees" name="taskAssignees" class="form-group__input" placeholder="콤마(,)로 구분">
                    </div>
                    <div class="form-group">
                        <label for="taskPriority" class="form-group__label">중요도</label>
                        <select id="taskPriority" name="taskPriority" class="form-group__select">
                            <option value="low">낮음</option>
                            <option value="medium" selected>보통</option>
                            <option value="high">높음</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tagInput" class="form-group__label">태그</label>
                        <div id="tagsContainer" class="form-group__tags" aria-live="polite"></div>
                        <input type="text" id="tagInput" class="form-group__tag-input" placeholder="태그 입력 후 엔터">
                    </div>

                    <div class="form-actions">
                        <button type="button" class="btn btn--secondary" onclick="app.closeModal()">취소</button>
                        <button type="submit" class="btn btn--primary">저장</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Detail Modal -->
        <div id="taskDetailModal" class="modal" role="dialog" aria-labelledby="taskDetailTitle" aria-hidden="true">
            <div class="modal__content">
                <div class="modal__header">
                    <div id="taskDetailTitle" class="modal__title">업무 상세</div>
                    <button class="modal__close" aria-label="상세 정보 모달 닫기" onclick="app.closeDetailModal()">×</button>
                </div>
                <div id="taskDetailContent">
                    <!-- Content will be populated by JS -->
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn--secondary" onclick="app.closeDetailModal()">닫기</button>
                </div>
            </div>
        </div>
    </div>

    <!-- AI 인터페이스 -->
    <div class="ai-interface" id="aiInterface" aria-hidden="true">
        <div class="ai-header">
            <div class="ai-title">AI 업무 도우미</div>
            <button class="ai-close-btn" id="closeAI" aria-label="AI 인터페이스 닫기">✕</button>
        </div>
        <div class="ai-input-container">
            <input type="text" id="aiPrompt" placeholder="업무 지시를 입력하세요 (예: '마감일 임박 작업 정렬')">
            <button id="executeAI" aria-label="AI 명령어 실행">실행</button>
        </div>
        <div class="ai-suggestions">
            <div class="ai-suggestion" data-prompt="오늘 마감인 작업은?">오늘 마감인인 작업</div>
            <div class="ai-suggestion" data-prompt="마감되지 않은 작업들만 우선순위로 정렬해줘">우선 순위로 정렬 해줘</div>
            <div class="ai-suggestion" data-prompt="완료된 작업 숨기기 또는 아카이브">완료 작업 정리</div>
            <div class="ai-suggestion" data-prompt="'매일할일' 에 '책상 정리' 추가해줘">새 업무 추가 예시</div>
            <div class="ai-suggestion" data-prompt="마감일 지난 업무 정리해줘">마감일 지난 업무</div>
            <!--<div class="ai-suggestion" data-prompt="오늘 마감인 업무에 '긴급' 태그 추가">오늘 마감 태그 추가</div>-->
        </div>
        <div class="ai-response" id="aiResponse" aria-live="assertive"></div>
    </div>

    <script>
        // --- Constants ---
        const LOCAL_STORAGE_DATA_KEY = 'taskAppData_v2'; // Versioning for potential structure changes
        const LOCAL_STORAGE_SETTINGS_KEY = 'taskAppSettings_v2';
        const JAN_API_BASE_URL = "http://127.0.0.1:1337/v1";
        const JAN_API_CHAT_ENDPOINT = "/chat/completions";
        const JAN_API_MODELS_ENDPOINT = "/models";
        const DEBOUNCE_DELAY = 300; // ms for search input debounce

        // --- Utility Functions ---
        const utils = {
            generateId: () => `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(this, args); // Use apply to maintain context
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },
            formatDueDateForDisplay: (dueDateString) => {
                if (!dueDateString) return '날짜 없음';
                try {
                    const date = new Date(dueDateString);
                    date.setHours(0, 0, 0, 0);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const tomorrow = new Date(today);
                    tomorrow.setDate(today.getDate() + 1);

                    const timeDiff = date.getTime() - today.getTime();
                    const dayDiff = Math.ceil(timeDiff / (1000 * 3600 * 24)); // Use Math.ceil

                    if (dayDiff < 0) return '기한지남';
                    if (dayDiff === 0) return '오늘';
                    if (dayDiff === 1) return '내일';

                    // More robust date formatting
                    return date.toLocaleDateString('ko-KR', { year: 'numeric', month: 'short', day: 'numeric' });
                } catch (e) {
                    console.error("Error formatting date:", dueDateString, e);
                    return '날짜 형식 오류';
                }
            },
            getDueDateClass: (dueDateString) => {
                if (!dueDateString) return '';
                try {
                    const date = new Date(dueDateString);
                    date.setHours(0, 0, 0, 0);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);

                    const timeDiff = date.getTime() - today.getTime();
                    const dayDiff = Math.ceil(timeDiff / (1000 * 3600 * 24)); // Use Math.ceil

                    if (dayDiff < 0) return 'task__due-date--overdue';
                    if (dayDiff === 0) return 'task__due-date--today';
                    if (dayDiff === 1) return 'task__due-date--tomorrow';
                    return '';
                } catch (e) {
                    return '';
                }
            },
            // Simple alert for feedback (replace with a Toast library later if needed)
            showFeedback: (message, type = 'info') => {
                // console[type](message); // Log to console as well
                alert(`[${type.toUpperCase()}] ${message}`);
            },
            escapeHtml: (unsafe) => {
                 return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }
        };

        const app = (function(utils) {
            // --- State ---
            let appData = {
                tasks: [],
                columns: [
                    { id: 'daily', title: '매일 할일', order: 0 },
                    { id: 'input', title: '인폼 사항', order: 1 },
                    { id: 'instruction1', title: '지시 사항 1', order: 2 },
                    { id: 'instruction2', title: '지시 사항 2', order: 3 },
                    { id: 'pgm', title: 'PGM 변경 내역', order: 4 }
                ],
                settings: {
                    darkMode: false,
                    showQuickAdd: true
                },
                janAI: {
                    connected: false,
                    model: null,
                    availableModels: []
                }
            };

            let draggedTask = null;
            let dragPlaceholder = null;
            let currentMenu = null;
            let currentTags = [];

            // --- DOM Elements ---
            const board = document.getElementById('board');
            const taskModal = document.getElementById('taskModal');
            const taskForm = document.getElementById('taskForm');
            const modalTitle = document.getElementById('modalTitle');
            const searchInput = document.getElementById('searchInput');
            const detailModal = document.getElementById('taskDetailModal');
            const detailContent = document.getElementById('taskDetailContent');
            const tagInput = document.getElementById('tagInput');
            const tagsContainer = document.getElementById('tagsContainer');
            const themeToggle = document.querySelector('.header__theme-toggle');
            const aiModelSelector = document.getElementById('aiModelSelector');
            const toggleAI = document.getElementById('toggleAI');
            const aiOrganize = document.getElementById('aiOrganize');
            const aiInterface = document.getElementById('aiInterface');
            const aiPrompt = document.getElementById('aiPrompt');
            const executeAI = document.getElementById('executeAI');
            const closeAI = document.getElementById('closeAI');
            const aiResponse = document.getElementById('aiResponse');
            const aiSuggestions = document.querySelector('.ai-suggestions');

            // --- 탭 관리자 객체 ---
            // DOM 요소들이 정의된 *후*, 이를 사용하는 함수들(init 등)이 정의되기 *전*에 위치해야 함
            const tabManager = {
                tabs: document.querySelectorAll('.tabs__tab'),
                contents: document.querySelectorAll('.tab-content'),
                boardElement: document.getElementById('board'), // 대시보드 요소

                activateTab: function(activeIndex) {
                    if (!this.tabs || !this.contents || !this.boardElement) {
                        console.error("TabManager: 필수 DOM 요소가 없습니다.");
                        return;
                    }

                    this.tabs.forEach((tab, index) => {
                        const content = this.contents[index];
                        if (index === activeIndex) {
                            tab.classList.add('tabs__tab--active');
                            if (content) {
                                content.classList.add('tab-content--active');
                                if (content.id === 'pgm-history-content') {
                                    if (typeof app !== 'undefined' && typeof app.renderPgmHistory === 'function') {
                                        app.renderPgmHistory(); // app 객체 및 함수 존재 확인
                                    }
                                    this.boardElement.style.display = 'none';
                                } else if (content.id === 'dashboard-content') {
                                    this.boardElement.style.display = 'grid';
                                } else {
                                    this.boardElement.style.display = 'none';
                                }
                            }
                        } else {
                            tab.classList.remove('tabs__tab--active');
                            if (content) content.classList.remove('tab-content--active');
                        }
                    });

                    // 기본 탭 처리 로직
                    const anyTabActive = Array.from(this.contents).some(c => c && c.classList.contains('tab-content--active'));
                    const dashboardContent = this.contents[0]; // Assume first tab is dashboard

                    if (!anyTabActive && dashboardContent && dashboardContent.id === 'dashboard-content') {
                         if(this.tabs[0]) this.tabs[0].classList.add('tabs__tab--active');
                         dashboardContent.classList.add('tab-content--active');
                         this.boardElement.style.display = 'grid';
                    } else if (anyTabActive && dashboardContent && dashboardContent.id === 'dashboard-content' && !dashboardContent.classList.contains('tab-content--active')) {
                        this.boardElement.style.display = 'none';
                    }
                }
            };

            // --- Jan API Class ---
            class JanAI {
                constructor() {
                    this.baseUrl = JAN_API_BASE_URL;
                    this.chatEndpoint = JAN_API_CHAT_ENDPOINT;
                    this.modelsEndpoint = JAN_API_MODELS_ENDPOINT;
                }

            // JanAI 클래스 내 checkConnection 함수 수정

            async checkConnection() {
                // ... (기존 코드: fetch 요청 전까지)
                try {
                    const response = await fetch(`${this.baseUrl}${this.modelsEndpoint}`); // 필요하다면 여기에 파라미터 추가 (가능성 3 참고)
                    if (!response.ok) throw new Error(`API 연결 실패 (${response.status})`);

                    const data = await response.json();
                    const allModels = data.data || [];

                    // --- 여기가 중요: 로컬/다운로드된 모델만 필터링 ---
                    // 예시: 만약 모델 객체에 'status' 속성이 있고, 준비된 상태가 'downloaded' 인 모델만 리스트업 해서 띄움
                    // 확인 방법 개발자 도구>네트워크>response> 로컬 모델과 아닌모델 비교시 downloaded와 downloadable의 차이점이 있었음음
                    const localModels = allModels.filter(model => model.status === 'downloaded' /* 또는 model.downloaded === true 등 */);
                    // 또는 ID 형식을 보고 필터링해야 할 수도 있습니다. (예: model.id.startsWith('local-') )

                    // appData 업데이트 및 모델 선택기 채우기는 필터링된 목록(localModels)으로 수행
                    appData.janAI.connected = true;
                    appData.janAI.availableModels = localModels; // 필터링된 목록 저장

                    if (localModels.length > 0) {
                        appData.janAI.model = localModels[0].id; // 기본 선택도 필터링된 목록에서
                        this.updateModelSelector(localModels);   // 선택기 업데이트도 필터링된 목록으로
                        aiModelSelector.disabled = false;
                        toggleAI.disabled = false;
                        aiOrganize.disabled = false;
                        console.info("Jan.ai 연결 성공 (로컬 모델 필터링됨):", localModels.map(m => m.id).join(', '));
                    } else {
                        // 필터링 후 모델이 하나도 없다면
                        throw new Error("사용 가능한 로컬 AI 모델이 없습니다.");
                    }
                    return { connected: true, models: localModels }; // 반환값도 필터링된 목록으로

                } catch (error) {
                    // ... (기존 에러 처리 코드)
                    console.error("Jan.ai 연결 또는 모델 필터링 오류:", error);
                    // ...
                }
            }

                updateModelSelector(models) {
                    aiModelSelector.innerHTML = ''; // Clear existing options
                    if (models.length === 0) {
                        aiModelSelector.innerHTML = '<option value="">사용 가능한 모델 없음</option>';
                        aiModelSelector.disabled = true;
                        return;
                    }

                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.id.length > 30 ? model.id.substring(0, 27) + '...' : model.id; // Shorten long names
                        option.title = model.id; // Full name on hover
                        aiModelSelector.appendChild(option);
                    });

                    aiModelSelector.value = appData.janAI.model || models[0].id;
                    aiModelSelector.disabled = false;
                }

                async sendPrompt(prompt, systemMessage = null) {
                    if (!appData.janAI.connected || !appData.janAI.model) {
                        throw new Error("Jan에 연결되지 않았거나 모델이 선택되지 않았습니다.");
                    }

                    setAIProcessing(true); // Disable button, show loading

                    const messages = [];
                    if (systemMessage) {
                        messages.push({ role: "system", content: systemMessage });
                    }
                    messages.push({ role: "user", content: prompt });

                    try {
                        const response = await fetch(`${this.baseUrl}${this.chatEndpoint}`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                model: appData.janAI.model,
                                messages: messages,
                                temperature: 0.7, // Consider making configurable
                                max_tokens: 1500 // Adjust as needed
                            })
                        });

                        if (!response.ok) {
                            const errorBody = await response.text();
                            throw new Error(`API 요청 실패 (${response.status}): ${errorBody}`);
                        }

                        return await response.json();
                    } finally {
                        setAIProcessing(false); // Re-enable button
                    }
                }
            }
            const janAI = new JanAI();

            // --- Data Management ---
            // 기존 loadData 함수 내용을 아래 코드로 변경 (async 키워드 추가)
            const loadData = async () => {
                try {
                    console.log('서버에서 데이터 로딩 시도...');
                    const response = await fetch('/api/data'); // 서버 API 호출!
                    if (!response.ok) throw new Error(`데이터 로딩 실패: ${response.status} ${response.statusText}`);
                    const data = await response.json(); // 서버 응답(JSON) 받기
                    
                    console.log('서버에서 받은 원본 데이터:', data);
                    
                    // 태스크 데이터 처리
                    if (Array.isArray(data.tasks)) {
                        appData.tasks = data.tasks;
                        console.log(`서버에서 ${data.tasks.length}개의 태스크 로드됨`);
                    } else {
                        console.warn('서버에서 태스크 데이터가 배열 형태가 아님:', data.tasks);
                        appData.tasks = [];
                    }
                    
                    // 컬럼 데이터 처리
                    if (Array.isArray(data.columns)) {
                        appData.columns = data.columns.map(col => ({
                            ...col,
                            order: col.ord || 0 // ord 속성이 없는 경우 기본값 0 설정
                        }));
                        console.log(`서버에서 ${data.columns.length}개의 컬럼 로드됨:`, appData.columns);
                    } else {
                        console.warn('서버에서 컬럼 데이터가 배열 형태가 아님:', data.columns);
                        // 기본 컬럼 유지 (초기화 시 설정된 값)
                    }

                    console.log('서버 데이터 로딩 완료. appData 상태:', appData);
                    
                    // UI 업데이트
                    renderBoard(); // 화면 그리기
                    renderPgmHistory(); // PGM 탭 그리기
                } catch (error) {
                    console.error("데이터 로드 오류:", error);
                    alert("데이터를 불러오는데 실패했습니다: " + error.message);
                    
                    // 오류 발생시 테스트 데이터로 대체
                    console.log('오류 발생으로 테스트 데이터를 사용합니다.');
                    appData.tasks = [
                        {
                            id: 'task_test_1',
                            columnId: 'daily',
                            title: '첫 번째 할일',
                            description: '첫 번째 테스트 할일입니다.',
                            priority: 'high',
                            tags: ['중요', '테스트'],
                            completed: false
                        },
                        {
                            id: 'task_test_2',
                            columnId: 'input',
                            title: '인폼 관련 업무',
                            description: '인폼 관련 테스트 업무입니다.',
                            priority: 'medium',
                            tags: ['인폼'],
                            completed: false
                        },
                        {
                            id: 'task_test_3',
                            columnId: 'instruction1',
                            title: '지시사항 확인',
                            description: '지시사항 확인 테스트입니다.',
                            priority: 'low',
                            completed: true
                        },
                        {
                            id: 'task_test_4',
                            columnId: 'instruction2',
                            title: '두번째 지시사항',
                            description: '두번째 지시사항 테스트입니다.',
                            priority: 'medium',
                            tags: ['참고'],
                            completed: false
                        },
                        {
                            id: 'task_test_5',
                            columnId: 'pgm',
                            title: 'PGM 변경건',
                            description: 'PGM 변경 테스트입니다.',
                            priority: 'high',
                            tags: ['긴급', 'PGM'],
                            completed: false
                        }
                    ];
                    
                    // 기본 데이터로 화면 렌더링
                    renderBoard(); 
                    renderPgmHistory();
                }
                // 테마 적용
                applyTheme();
            };
            
            // --- 앱 초기화 함수 ---
            const init = async () => {
                console.log("Initializing Task Board...");
                
                // 테마 설정 적용
                applyTheme();
                
                // 기본 이벤트 리스너 추가
                board.addEventListener('click', handleBoardClick);
                taskForm.addEventListener('submit', handleFormSubmit);
                searchInput.addEventListener('input', (e) => debouncedFilterTasks(e.target.value));
                themeToggle.addEventListener('click', toggleDarkMode);
                document.addEventListener('keydown', handleKeyDown);
                
                // 태그 입력 리스너
                tagInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (tagInput.value.trim()) {
                            addTag(tagInput.value);
                        }
                    }
                });
                
                // PGM 히스토리 탭의 하위 컬럼 '+' 버튼 리스너
                document.querySelectorAll('.sub-column-add-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const columnId = btn.dataset.columnTarget;
                        openTaskModal('add', columnId);
                    });
                });
                
                // 탭 기능 활성화
                document.querySelectorAll('.tabs__tab').forEach((tab, index) => {
                    tab.addEventListener('click', function() {
                        tabManager.activateTab(index);
                    });
                });
                
                // AI 인터페이스 리스너 설정 (Jan.AI가 있다면)
                if (typeof janAI !== 'undefined') {
                    aiModelSelector.addEventListener('change', (e) => {
                        const selectedModel = e.target.value;
                        if (selectedModel && appData.janAI.availableModels.some(m => m.id === selectedModel)) {
                            appData.janAI.model = selectedModel;
                        }
                    });
                    
                    toggleAI.addEventListener('click', () => {
                        const isActive = aiInterface.classList.toggle('active');
                        aiInterface.setAttribute('aria-hidden', !isActive);
                        if (isActive) aiPrompt.focus();
                    });
                    
                    closeAI.addEventListener('click', () => {
                        aiInterface.classList.remove('active');
                        aiInterface.setAttribute('aria-hidden', 'true');
                    });
                    
                    executeAI.addEventListener('click', () => {
                        if (typeof processAICommand === 'function') {
                            processAICommand(aiPrompt.value.trim());
                        }
                    });
                    
                    aiPrompt.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            executeAI.click();
                        }
                    });
                    
                    if (typeof organizeTasksWithAI === 'function') {
                        aiOrganize.addEventListener('click', organizeTasksWithAI);
                    }
                    
                    aiSuggestions.addEventListener('click', (e) => {
                        const suggestion = e.target.closest('.ai-suggestion');
                        if (suggestion) {
                            const promptText = suggestion.dataset.prompt || suggestion.textContent;
                            aiPrompt.value = promptText;
                            aiPrompt.focus();
                        }
                    });
                    
                    // AI 연결 확인 시도 (에러는 무시)
                    try {
                        await janAI.checkConnection();
                    } catch (err) {
                        console.warn("Jan AI 연결 확인 실패:", err);
                    }
                }
                
                // 서버에서 데이터 로드 시도
                try {
                    await loadData();
                    console.log("데이터 로드 완료, 화면 렌더링됨");
                } catch (error) {
                    console.error("데이터 로드 중 오류:", error);
                    // loadData 내에서 이미 오류 처리 및 기본 데이터 설정함
                }
                
                console.log("Task Board 초기화 완료.");
            };
            
            // --- Utility Functions For UI ---
            const saveSettings = () => {
                try {
                    localStorage.setItem(LOCAL_STORAGE_SETTINGS_KEY, JSON.stringify(appData.settings));
                } catch (e) {
                    console.error("설정 저장 오류:", e);
                    // Less critical, maybe just log
                }
            };

            // --- Theme & Settings Application ---
            const applyTheme = () => {
                document.body.classList.toggle('theme-dark', appData.settings.darkMode);
                themeToggle.textContent = appData.settings.darkMode ? '☀️' : '🌙';
                themeToggle.setAttribute('aria-label', appData.settings.darkMode ? '라이트 모드 전환' : '다크 모드 전환');

                 // --- 중요: 초기 탭 상태 설정 및 보드 가시성 제어 ---
                 // 초기 로드 시 기본 탭(보통 첫 번째 탭)을 활성화합니다.
                 // tabManager가 이 시점에 정의되어 있어야 함!
                 const initialActiveTabIndex = Array.from(tabManager.tabs).findIndex(tab => tab.classList.contains('tabs__tab--active'));
                 tabManager.activateTab(initialActiveTabIndex >= 0 ? initialActiveTabIndex : 0); // 현재 활성 탭 또는 첫 번째 탭 활성화
            }

            const toggleDarkMode = () => {
                appData.settings.darkMode = !appData.settings.darkMode;
                applyTheme();
                saveSettings();
            };

            const applyQuickAddVisibility = () => {
                // TODO: If quick add toggle is implemented, update visibility here
                const quickAddElements = board.querySelectorAll('.column__quick-add');
                 quickAddElements.forEach(el => {
                     el.style.display = appData.settings.showQuickAdd ? 'block' : 'none'; // Direct style for now
                 });
            };

            // --- Rendering ---
            const getTaskDataById = (id) => appData.tasks.find(task => task.id === id);
            const getColumnElementById = (id) => board.querySelector(`.column[data-column-id="${id}"]`);
            const getColumnTitleElement = (columnId) => getColumnElementById(columnId)?.querySelector('.column__title');

            const createTaskElement = (task) => {
                const taskEl = document.createElement('div');
                taskEl.className = `task task--priority-${task.priority || 'medium'}`;
                taskEl.setAttribute('draggable', true);
                taskEl.dataset.taskId = task.id;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'task__checkbox';
                checkbox.checked = task.completed;
                checkbox.dataset.action = 'toggleComplete';
                checkbox.setAttribute('aria-label', `업무 ${task.completed ? '미완료로' : '완료로'} 표시: ${task.title}`);
                
                // 체크박스에 change 이벤트 리스너 추가 - 실시간 시각적 피드백 위함
                checkbox.addEventListener('change', (e) => {
                    const titleEl = taskEl.querySelector('.task__title');
                    if (titleEl) {
                        titleEl.classList.toggle('task__title--completed', e.target.checked);
                    }
                });
                
                taskEl.appendChild(checkbox);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'task__content';

                const titleEl = document.createElement('div');
                titleEl.className = `task__title ${task.completed ? 'task__title--completed' : ''}`;
                titleEl.textContent = task.title;
                titleEl.dataset.action = 'openDetail'; // Changed from openEdit to openDetail by default
                contentDiv.appendChild(titleEl);

                const metaEl = document.createElement('div');
                metaEl.className = 'task__meta';

                const dueDateEl = document.createElement('div');
                dueDateEl.className = `task__meta-item ${utils.getDueDateClass(task.dueDate)}`;
                dueDateEl.innerHTML = `<span>🗓️</span> ${utils.formatDueDateForDisplay(task.dueDate)}`;
                metaEl.appendChild(dueDateEl);

                if (task.assignees) {
                    const assigneesEl = document.createElement('div');
                    assigneesEl.className = 'task__meta-item';
                    assigneesEl.innerHTML = `<span>👤</span> ${utils.escapeHtml(task.assignees)}`;
                    metaEl.appendChild(assigneesEl);
                }
                contentDiv.appendChild(metaEl);

                if (task.tags && task.tags.length > 0) {
                    const tagsEl = document.createElement('div');
                    tagsEl.className = 'task__tags';
                    task.tags.forEach(tag => {
                        const tagEl = document.createElement('span');
                        tagEl.className = 'task__tag';
                        tagEl.textContent = utils.escapeHtml(tag);
                        tagsEl.appendChild(tagEl);
                    });
                    contentDiv.appendChild(tagsEl);
                }
                taskEl.appendChild(contentDiv);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'task__delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.dataset.action = 'deleteTask';
                deleteBtn.setAttribute('aria-label', `업무 삭제: ${task.title}`);
                taskEl.appendChild(deleteBtn);

                taskEl.addEventListener('dragstart', handleDragStart);
                taskEl.addEventListener('dragend', handleDragEnd);
                taskEl.addEventListener('dblclick', () => openTaskModal('edit', null, task.id)); // Double click to edit

                return taskEl;
            };

            const renderBoard = () => {
                console.log('renderBoard 함수 호출됨. 현재 appData 상태:', {
                    columns: appData.columns.length,
                    tasks: appData.tasks.length
                });
                
                board.innerHTML = ''; // Clear board
                
                // 컬럼이 없으면 메시지 표시
                if (!appData.columns || appData.columns.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.className = 'empty-board-message';
                    emptyMsg.textContent = '컬럼 데이터가 없습니다. 서버 연결을 확인해주세요.';
                    board.appendChild(emptyMsg);
                    console.warn('렌더링할 컬럼 데이터가 없음');
                    return;
                }
                
                const sortedColumns = [...appData.columns].sort((a, b) => (a.order || 0) - (b.order || 0));
                console.log('정렬된 컬럼:', sortedColumns);

                sortedColumns.forEach(column => {
                    const columnEl = document.createElement('div');
                    columnEl.className = 'column';
                    columnEl.dataset.columnId = column.id;

                    // --- Header ---
                    const headerEl = document.createElement('div');
                    headerEl.className = 'column__header';

                    const titleAreaEl = document.createElement('div');
                    titleAreaEl.className = 'column__title-area';

                    const titleEl = document.createElement('span');
                    titleEl.className = 'column__title';
                    titleEl.textContent = column.title;
                    titleEl.title = "더블클릭하여 이름 수정"; // Tooltip
                    titleEl.addEventListener('dblclick', () => startEditingColumnTitle(titleAreaEl)); // Double click to edit title

                    const counterEl = document.createElement('span');
                    counterEl.className = 'column__counter';
                    counterEl.setAttribute('aria-live', 'polite'); // Announce changes

                    titleAreaEl.appendChild(titleEl);
                    titleAreaEl.appendChild(counterEl);

                    headerEl.appendChild(titleAreaEl);

                    const actionsEl = document.createElement('div');
                    actionsEl.className = 'column__actions';

                    const addBtn = document.createElement('button');
                    addBtn.className = 'action-btn action-btn--add';
                    addBtn.dataset.action = 'addTask';
                    addBtn.dataset.columnTarget = column.id;
                    addBtn.setAttribute('aria-label', `${column.title} 컬럼에 새 업무 추가`);
                    addBtn.textContent = '+';
                    actionsEl.appendChild(addBtn);

                    const menuBtn = document.createElement('button');
                    menuBtn.className = 'action-btn action-btn--menu';
                    menuBtn.dataset.action = 'openColumnMenu';
                    menuBtn.dataset.columnTarget = column.id;
                    menuBtn.setAttribute('aria-label', `${column.title} 컬럼 메뉴 열기`);
                    menuBtn.textContent = '⋮';
                    actionsEl.appendChild(menuBtn);

                    headerEl.appendChild(actionsEl);
                    columnEl.appendChild(headerEl);

                    // --- Content ---
                    const contentEl = document.createElement('div');
                    contentEl.className = 'column__content';
                    contentEl.dataset.columnId = column.id;
                    contentEl.addEventListener('dragover', handleDragOver);
                    contentEl.addEventListener('dragleave', handleDragLeave);
                    contentEl.addEventListener('drop', handleDrop);

                    // 태스크 필터링 및 정렬
                    const tasksForColumn = appData.tasks.filter(task => task.columnId === column.id);
                    console.log(`컬럼 ${column.id}의 태스크 수: ${tasksForColumn.length}`);
                    
                    const sortedTasks = [...tasksForColumn].sort((a, b) => {
                        // 날짜 기준 정렬 (없으면 맨 뒤로)
                        const dateA = a.dueDate ? new Date(a.dueDate) : new Date('9999-12-31');
                        const dateB = b.dueDate ? new Date(b.dueDate) : new Date('9999-12-31');
                        return dateA - dateB;
                    });

                    if (sortedTasks.length === 0) {
                        contentEl.appendChild(createEmptyState());
                    } else {
                        sortedTasks.forEach(task => {
                            try {
                                const taskEl = createTaskElement(task);
                                contentEl.appendChild(taskEl);
                            } catch (error) {
                                console.error(`태스크 렌더링 오류 (ID: ${task.id}):`, error, task);
                            }
                        });
                    }
                    
                    columnEl.appendChild(contentEl);

                    // Update counter after tasks are added
                    counterEl.textContent = sortedTasks.length;

                    // --- Quick Add ---
                    if (appData.settings.showQuickAdd) {
                        const quickAddEl = document.createElement('div');
                        quickAddEl.className = 'column__quick-add';
                        quickAddEl.style.display = appData.settings.showQuickAdd ? 'block' : 'none'; // Direct style for now

                        const inputEl = document.createElement('input');
                        inputEl.className = 'column__quick-add-input';
                        inputEl.placeholder = '빠른 추가 (Enter)';
                        inputEl.dataset.columnId = column.id;
                        inputEl.setAttribute('aria-label', `${column.title}에 빠른 업무 추가`);

                        inputEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' && e.target.value.trim()) {
                                const newTitle = e.target.value.trim();
                                addTask({
                                    columnId: column.id,
                                    title: newTitle,
                                });
                                e.target.value = '';
                                utils.showFeedback(`'${newTitle}' 업무 추가됨`);
                            }
                        });
                        quickAddEl.appendChild(inputEl);
                        columnEl.appendChild(quickAddEl);
                    }

                    board.appendChild(columnEl);
                });

                // Re-apply search filter if needed
                const currentSearchTerm = searchInput.value.trim();
                if (currentSearchTerm) {
                    filterTasks(currentSearchTerm);
                }
                
                console.log('보드 렌더링 완료');
            };


             const renderPgmHistory = () => {
                 console.log("[renderPgmHistory] 함수 시작됨.");
                 const pgmSubColumns = ['AVI-red', 'AVI-yellow', 'ATTACH-black', 'ATTACH-pink'];
                 
                 pgmSubColumns.forEach(subColumnId => {
                     const contentEl = getPgmSubColumnContentElement(subColumnId);
                     console.log(`[renderPgmHistory] Processing sub-column: ${subColumnId}. Container found:`, !!contentEl);
                     
                     if (contentEl) {
                         contentEl.innerHTML = ''; // Clear previous content
                         
                         // Get tasks for this sub-column
                         const tasks = app.appData.tasks.filter(task => task.columnId === subColumnId);
                         console.log(`[renderPgmHistory] Tasks found for ${subColumnId}: ${tasks.length}`);
                         
                         if (tasks.length === 0) {
                             const emptyState = createEmptyState();
                             contentEl.appendChild(emptyState);
                         } else {
                             tasks.forEach(task => {
                                 try {
                                     const taskEl = app.createTaskElement(task);
                                     contentEl.appendChild(taskEl);
                                     console.log(`[renderPgmHistory] Appended task ${task.id} to ${subColumnId}`);
                                 } catch (error) {
                                     console.error(`[renderPgmHistory] Error creating task element for ${task.id}:`, error);
                                 }
                             });
                         }

                         // Set up event listeners
                         contentEl.removeEventListener('dragover', handleDragOver);
                         contentEl.removeEventListener('dragleave', handleDragLeave);
                         contentEl.removeEventListener('drop', handleDrop);
                         contentEl.addEventListener('dragover', handleDragOver);
                         contentEl.addEventListener('dragleave', handleDragLeave);
                         contentEl.addEventListener('drop', handleDrop);

                         // Set up click handler for tasks
                         contentEl.removeEventListener('click', handlePgmColumnClick);
                         contentEl.addEventListener('click', handlePgmColumnClick);
                     } else {
                         console.warn(`[renderPgmHistory] Container element not found for sub-column ID: ${subColumnId}`);
                     }
                 });
                 
                 console.log("[renderPgmHistory] 함수 종료됨.");
             };

            // --- PGM Column Click Handler (Event Delegation) ---
            const handlePgmColumnClick = (event) => {
                const target = event.target;
                const taskEl = target.closest('.task');

                if (!taskEl) return; // Click wasn't inside a task

                const taskId = taskEl.dataset.taskId;
                const actionTarget = target.closest('[data-action]');
                const action = actionTarget?.dataset.action;

                console.log(`[handlePgmColumnClick] Click detected on task ${taskId}. Action target:`, actionTarget, `Action: ${action}`);

                if (action === 'deleteTask') {
                    const task = app.getTaskDataById(taskId);
                    if (task && confirm(`'${task.title}' 업무를 삭제하시겠습니까?`)) {
                        deleteTask(taskId);
                    }
                } else if (action === 'toggleComplete') {
                    // Checkbox click
                    if (target.matches('.task__checkbox')) {
                        toggleComplete(taskId);
                    }
                } else if (action === 'openDetail') {
                     // Open detail modal when clicking title or general task area
                     if (!target.matches('.task__checkbox') && !target.matches('.task__delete-btn')) {
                         openDetailModal(taskId);
                     }
                }
            };

            // --- JanAI 클래스 외부 ---

            const createEmptyState = () => {
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-state';
                emptyState.textContent = '업무가 없습니다';
                return emptyState;
            };

            const updateColumnCounter = (columnId) => {
                const column = getColumnElementById(columnId);
                if (column) {
                    const counter = column.querySelector('.column__counter');
                    const content = column.querySelector('.column__content');
                    const taskCount = content ? content.querySelectorAll('.task').length : 0;
                    if (counter) counter.textContent = taskCount;

                    // Toggle empty state
                    const emptyState = content.querySelector('.empty-state');
                    if (taskCount === 0 && !emptyState) {
                        content.appendChild(createEmptyState());
                    } else if (taskCount > 0 && emptyState) {
                        emptyState.remove();
                    }
                }
            };

            // --- Task Management ---
            // 기존 addTask 함수 내용을 아래 코드로 변경 (async 키워드 추가)
            const addTask = async (taskData) => {
                const newTask = {
                    id: utils.generateId(), // 새 ID 생성
                    completed: false,
                    priority: 'medium',
                    ...taskData // title, columnId 등 포함
                };

                try {
                    const response = await fetch('/api/tasks', { // 서버 API 호출!
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newTask) // 새 태스크 정보 전송
                    });
                    if (!response.ok) throw new Error('태스크 추가 실패');
                    const addedTask = await response.json(); // 서버에서 최종 데이터 받기

                    // 성공 시: 로컬 데이터 업데이트 및 화면 업데이트
                    appData.tasks.push(addedTask);
                    renderSingleTask(addedTask); // 화면에 새 태스크 추가 (도우미 함수 필요, 아래 참고)
                    updateColumnCounter(addedTask.columnId); // 카운터 업데이트
                    // utils.showFeedback(...) // 성공 피드백

                } catch (error) {
                    console.error("태스크 추가 오류:", error);
                    alert("태스크 추가에 실패했습니다.");
                }
                // saveData() 호출 삭제!
            };

            // 기존 updateTask 함수 내용을 아래 코드로 변경 (async 키워드 추가)
            const updateTask = async (taskId, updatedData) => {
                // tags는 currentTags 사용 (모달 상태)
                const payload = { ...updatedData, tags: currentTags };

                try {
                    const response = await fetch(`/api/tasks/${taskId}`, { // 서버 API 호출!
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload) // 수정할 내용 전송
                    });
                    if (!response.ok) throw new Error('태스크 수정 실패');
                    const returnedTask = await response.json(); // 서버 응답 받기

                    // 성공 시: 로컬 데이터 업데이트 및 화면 업데이트
                    const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
                    if (taskIndex > -1) {
                        // 서버 응답 대신, 보낸 데이터 기준으로 로컬 업데이트
                        appData.tasks[taskIndex] = { ...appData.tasks[taskIndex], ...payload };
                        rerenderSingleTask(taskId); // 화면 업데이트 (도우미 함수 필요, 아래 참고)
                    }
                    // utils.showFeedback(...) // 성공 피드백
                } catch (error) {
                    console.error("태스크 수정 오류:", error);
                    alert("태스크 수정에 실패했습니다.");
                }
                currentTags = []; // 모달 태그 초기화
                // saveData() 호출 삭제!
            };

            // 기존 deleteTask 함수 내용을 아래 코드로 변경 (async 키워드 추가)
            const deleteTask = async (taskId) => {
                try {
                    const response = await fetch(`/api/tasks/${taskId}`, { // 서버 API 호출!
                        method: 'DELETE'
                    });
                    if (!response.ok) throw new Error('태스크 삭제 실패');
                    const result = await response.json(); // 서버 응답 받기

                    // 성공 시: 로컬 데이터 업데이트 및 화면 업데이트
                    const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
                    if (taskIndex > -1) {
                        const deletedTask = appData.tasks.splice(taskIndex, 1)[0];
                        const columnId = deletedTask.columnId;
                        // 화면에서 요소 제거
                        const taskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
                        if (taskEl) taskEl.remove();
                        else renderPgmHistory(); // PGM 탭에만 있었다면 해당 탭 갱신
                        updateColumnCounter(columnId); // 카운터 업데이트
                        // utils.showFeedback(...) // 성공 피드백
                    }
                } catch (error) {
                    console.error("태스크 삭제 오류:", error);
                    alert("태스크 삭제에 실패했습니다.");
                }
                // saveData() 호출 삭제!
            };

            // 기존 toggleComplete 함수 내용을 아래 코드로 변경 (async 키워드 추가)
            const toggleComplete = async (taskId) => {
                const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
                if (taskIndex === -1) return;
                const task = appData.tasks[taskIndex];
                const newCompletedStatus = !task.completed;

                try {
                    const response = await fetch(`/api/tasks/${taskId}`, { // 서버 API 호출!
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ completed: newCompletedStatus }) // 완료 상태만 전송
                    });
                    if (!response.ok) throw new Error('완료 상태 변경 실패');

                    // 성공 시: 로컬 데이터 업데이트 및 화면 업데이트 (직접 조작)
                    task.completed = newCompletedStatus;
                    const taskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (taskEl) { 
                        // 체크박스는 이미 클릭 이벤트에서 change 리스너에 의해 시각적으로 업데이트되어 있으므로
                        // 여기서는 API 요청이 실패했을 때 원상복귀를 위한 코드만 필요합니다.
                        // 여기서는 별도 처리 없이 로그만 기록
                        console.log(`[toggleComplete] 서버 업데이트 성공: 업무 ${taskId}`);
                    }

                } catch (error) {
                    console.error("완료 상태 변경 오류:", error);
                    alert("완료 상태 변경에 실패했습니다.");
                    
                    // 실패 시 UI 원복
                    const taskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (taskEl) {
                        const checkbox = taskEl.querySelector('.task__checkbox');
                        if (checkbox) {
                            checkbox.checked = task.completed; // 원래 상태로 되돌림
                            // change 이벤트가 다시 발생하지 않으므로 수동으로 스타일 조정
                            taskEl.querySelector('.task__title')?.classList.toggle('task__title--completed', task.completed);
                        }
                    }
                }
                // saveData() 호출 삭제!
            };

                // 기존 moveTask 함수 내용을 아래 코드로 변경 (async 키워드 추가)
                const moveTask = async (taskId, targetColumnId, insertBeforeTaskId = null) => {
                    const taskIndex = appData.tasks.findIndex(t => t.id === taskId);
                    if (taskIndex === -1) return;
                    const originalColumnId = appData.tasks[taskIndex].columnId;

                    // UI는 드래그 종료 시 이미 이동된 상태일 수 있음 (Optimistic UI)

                    try {
                        const response = await fetch(`/api/tasks/${taskId}`, { // 서버 API 호출!
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ columnId: targetColumnId }) // 새 컬럼 ID 전송
                        });
                        if (!response.ok) throw new Error('태스크 이동 실패');

                        // 성공 시: 로컬 데이터 업데이트
                        appData.tasks[taskIndex].columnId = targetColumnId;
                        // UI 카운터 업데이트
                        updateColumnCounter(originalColumnId);
                        updateColumnCounter(targetColumnId);

                    } catch (error) {
                        console.error("태스크 이동 오류:", error);
                        alert("태스크 이동에 실패했습니다.");
                        // 실패 시 UI 원복 필요 (renderBoard(), renderPgmHistory() 호출 등)
                        renderBoard();
                        renderPgmHistory();
                    }
                    // saveData() 호출 삭제!
                };

            // --- Column Management ---
            const startEditingColumnTitle = (titleContainer) => {
                const titleSpan = titleContainer.querySelector('.column__title');
                // Prevent editing if already editing
                if (titleContainer.querySelector('.column__title-input')) return;

                const currentTitle = titleSpan.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentTitle;
                input.className = 'column__title-input';
                input.setAttribute('aria-label', '컬럼 이름 수정');

                titleSpan.style.display = 'none'; // Hide span
                titleContainer.insertBefore(input, titleSpan.nextSibling); // Insert input after span
                input.focus();
                input.select();

                const finishEditing = (save = true) => {
                    const columnId = titleContainer.closest('.column').dataset.columnId;
                    const newTitle = save ? input.value.trim() : currentTitle;

                    input.remove(); // Remove input first
                    titleSpan.style.display = ''; // Show span again

                    if (save && newTitle && newTitle !== currentTitle) {
                        updateColumnTitle(columnId, newTitle);
                        const columnElement = getColumnElementById(columnId);
                        columnElement.querySelector('.action-btn--add')?.setAttribute('aria-label', `${newTitle} 컬럼에 새 업무 추가`);
                        columnElement.querySelector('.action-btn--menu')?.setAttribute('aria-label', `${newTitle} 컬럼 메뉴 열기`);
                    } else {
                        titleSpan.textContent = currentTitle;
                    }
                };

                const handleBlur = () => finishEditing();
                const handleInputKeydown = (e) => {
                    if (e.key === 'Enter') finishEditing();
                    else if (e.key === 'Escape') finishEditing(false);
                };

                input.addEventListener('blur', handleBlur, { once: true }); // Use once to auto-remove
                input.addEventListener('keydown', handleInputKeydown);
            };

            const updateColumnTitle = (columnId, newTitle) => {
                const column = appData.columns.find(c => c.id === columnId);
                if (column && newTitle) {
                    column.title = newTitle;
                    saveData();
                    const titleEl = getColumnTitleElement(columnId);
                    if (titleEl) titleEl.textContent = newTitle;
                }
            };

            /*const deleteCompletedTasks = (columnId) => {    완료항목전체삭제제
                const columnTitle = getColumnTitleElement(columnId)?.textContent || `컬럼 ${columnId}`;
                const completedTasks = appData.tasks.filter(task => task.columnId === columnId && task.completed);

                if (completedTasks.length === 0) {
                    utils.showFeedback(`${columnTitle}에 완료된 항목이 없습니다.`);
                    return;
                }

                if (confirm(`${columnTitle}의 완료된 항목 ${completedTasks.length}개를 삭제하시겠습니까?`)) {
                    const initialLength = appData.tasks.length;
                    appData.tasks = appData.tasks.filter(task => !(task.columnId === columnId && task.completed));
                    if (appData.tasks.length < initialLength) {
                        saveData();
                        renderBoard(); // Re-render needed
                        utils.showFeedback(`${columnTitle}에서 ${completedTasks.length}개의 완료된 항목을 삭제했습니다.`);
                    }
                }
            };*/

            /*const deleteAllTasksFromColumn = (columnId) => { 천체삭제제
                const columnTitle = getColumnTitleElement(columnId)?.textContent || `컬럼 ${columnId}`;
                const tasksInColumn = appData.tasks.filter(task => task.columnId === columnId).length;

                if (tasksInColumn === 0) {
                    utils.showFeedback(`${columnTitle}에 삭제할 항목이 없습니다.`);
                    return;
                }

                if (confirm(`${columnTitle}의 모든 항목(${tasksInColumn}개)을 삭제하시겠습니까?`)) {
                    appData.tasks = appData.tasks.filter(task => task.columnId !== columnId);
                    saveData();
                    renderBoard(); // Re-render needed
                    utils.showFeedback(`${columnTitle}의 모든 항목 ${tasksInColumn}개를 삭제했습니다.`);
                }
            };*/

              // processAICommand 함수 내 수정
                // AI 처리 중 UI 상태 관리
                const setAIProcessing = (isProcessing) => {
                    executeAI.disabled = isProcessing;
                    executeAI.textContent = isProcessing ? '처리중...' : '실행';
                    aiPrompt.disabled = isProcessing;
                    
                    // 처리 중일 때 시각적 표시 추가
                    if (isProcessing) {
                        aiResponse.innerHTML = "<div class='ai-thinking'>🤔 생각 중입니다...</div>";
                    }
                };

                // AI 명령어 처리 - 개선된 프롬프트 엔지니어링
                const processAICommand = async (prompt) => {
                    if (!prompt || prompt.trim() === "") {
                        aiResponse.innerHTML = "<div class='ai-error'>명령어를 입력해주세요.</div>";
                        return;
                    }
                    
                    setAIProcessing(true);
                    
                    try {
                        // 사용자 명령어 분석 및 의도 파악
                        const commandType = await analyzeCommandIntent(prompt);
                        
                        // 명령어 유형에 따라 적절한 처리 수행
                        switch(commandType.type) {
                            case 'search':
                                await handleSearchCommand(prompt, commandType.keywords);
                                break;
                            case 'add':
                                await handleAddCommand(prompt, commandType.details);
                                break;
                            case 'update':
                                await handleUpdateCommand(prompt, commandType.taskInfo);
                                break;
                            case 'delete':
                                await handleDeleteCommand(prompt, commandType.taskInfo);
                                break;
                            case 'move':
                                await handleMoveCommand(prompt, commandType.taskInfo);
                                break;
                            case 'organize':
                                await handleOrganizeCommand(prompt);
                                break;
                            case 'date':
                                await handleDateCommand(prompt, commandType.dateInfo);
                                break;
                            case 'unknown':
                                default:
                                await handleGenericCommand(prompt);    
                        }
                    } catch (error) {
                        console.error("AI 명령어 처리 중 오류:", error);
                        const errorMessage = error.message || "AI 처리 중 알 수 없는 오류 발생";
                        aiResponse.innerHTML = `<div class='ai-error'>⚠️ ${utils.escapeHtml(errorMessage)}</div>`;
                    } finally {
                        setAIProcessing(false);
                    }
                };

                // 명령어 의도 분석 - 작은 모델에서도 잘 작동하는 간결한 프롬프트
                const analyzeCommandIntent = async (prompt) => {
                    const systemMessage = `
                    당신은 업무 관리 앱에 통합된 AI 비서입니다. 사용자의 입력을 분석하여 무엇을 하려는지 의도를 파악해주세요.
                    가능한 의도 유형: search(검색/찾기), add(추가/생성), update(수정/변경), delete(삭제), move(이동), organize(정리/정돈), date(마감일), unknown(기타),

                    JSON 형식으로 다음과 같이 간결하게 응답해주세요:
                    {
                    "type": "의도유형",
                    "keywords": ["관련키워드1", "관련키워드2"], // 검색어 또는 중요 단어
                    "details": {}, // 추가할 업무 정보(add 타입일 경우)
                    "taskInfo": {}, // 작업 관련 정보(update, delete, move 타입일 경우)
                    "dateInfo": { // date 타입일 경우
                        "action": "search/update/tag", // 찾기/수정/태그추가 등
                        "condition": "overdue/today/tomorrow/thisWeek" // 마감일 조건
                        }
                    }

                    예시 의도 파악:
                    - "홍길동 담당 업무 찾아줘" → {"type": "search", "keywords": ["홍길동", "담당"]}
                    - "프로젝트 기획 업무 추가해줘" → {"type": "add", "details": {"title": "프로젝트 기획"}}
                    - "보고서 마감일 다음 주로 변경" → {"type": "update", "taskInfo": {"title": "보고서", "field": "dueDate"}}
                    - "마감일 지난 업무 찾아줘" → {"type": "date", "keywords": ["마감일", "지난"], "dateInfo": {"action": "search", "condition": "overdue"}}
                    `;

                    try {
                        const response = await janAI.sendPrompt(prompt, systemMessage);
                        const aiContent = response?.choices?.[0]?.message?.content;
                        
                        if (!aiContent) throw new Error("의도 분석 응답을 받지 못했습니다.");
                        
                        // JSON 부분 추출 및 파싱
                        const jsonMatch = aiContent.match(/{[\s\S]*}/);
                        if (jsonMatch) {
                            try {
                                return JSON.parse(jsonMatch[0]);
                            } catch (parseError) {
                                console.warn("의도 분석 JSON 파싱 실패:", parseError);
                                // 기본값 반환
                                return { type: "unknown" };
                            }
                        } else {
                            return { type: "unknown" };
                        }
                     }
                 catch (error) {
                        console.error("의도 분석 오류:", error);
                        return { type: "unknown" };
                     }
                };

                // 검색 명령어 처리 - 작은 모델에 최적화
                const handleSearchCommand = async (originalPrompt, keywords) => {
                    // 검색 관련 task만 필터링하여 컨텍스트 제공
                    const relevantTasks = appData.tasks.filter(task => {
                        const searchableText = [
                            task.title || "",
                            task.description || "",
                            task.assignees || "",
                            (task.tags || []).join(" ")
                        ].join(" ").toLowerCase();
                        
                        return keywords.some(keyword => 
                            searchableText.includes(keyword.toLowerCase())
                        );
                    });
                    
                    // 검색 결과 개수에 따라 다른 프롬프트 사용
                    const systemMessage = relevantTasks.length > 0 
                        ? `
                다음은 '${keywords.join(", ")}' 키워드와 관련된 업무 목록입니다:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    assignees: t.assignees,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    completed: t.completed,
                    columnId: t.columnId
                })))}

                사용자 질문: "${originalPrompt}"

                위 정보를 바탕으로 사용자 질문에 정확히 답변해주세요. 
                반환 형식은 다음과 같습니다:
                {
                "message": "검색 결과에 대한 간결한 답변 (한국어)",
                "requires_confirmation": false,
                "proposed_actions": [
                    {
                    "type": "info",
                    "payload": {
                        "details": [검색된 업무 목록 또는 정보]
                    }
                    }
                ]
                }
                `
                        : `
                '${keywords.join(", ")}' 키워드와 관련된 업무를 찾을 수 없습니다.
                다음과 같이 응답해주세요:
                {
                "message": "관련 업무를 찾을 수 없습니다.",
                "requires_confirmation": false,
                "proposed_actions": []
                }
                `;
                    
                    const response = await janAI.sendPrompt("검색 결과 정리: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // 업무 추가 명령어 처리
                const handleAddCommand = async (originalPrompt, details) => {
                    // 컬럼 정보만 제공하여 컨텍스트 간소화
                    const columns = appData.columns.map(c => ({
                        id: c.id,
                        title: c.title
                    }));
                    
                    const systemMessage = `
                다음은 현재 사용 가능한 컬럼(보드) 목록입니다:
                ${JSON.stringify(columns)}

                사용자 요청: "${originalPrompt}"

                사용자가 새 업무를 추가하려고 합니다. 어느 컬럼에 어떤 내용의 업무를 추가해야 할지 분석해주세요.
                필수 정보: 업무명(title), 컬럼ID(columnId)
                선택 정보: 설명(description), 마감일(dueDate), 중요도(priority: low/medium/high), 담당자(assignees), 태그(tags)

                다음 JSON 형식으로 응답해주세요:
                {
                "message": "새 업무 추가 관련 확인 메시지 (한국어)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "add",
                    "payload": {
                        "columnId": "컬럼ID",
                        "title": "업무명",
                        "description": "설명",
                        "dueDate": "YYYY-MM-DD",
                        "priority": "중요도",
                        "assignees": "담당자",
                        "tags": ["태그1", "태그2"]
                    }
                    }
                ]
                }

                모든 필드가 확실하지 않다면, 가능한 부분만 채워서 응답하세요.
                `;
                    
                    const response = await janAI.sendPrompt("업무 추가 처리: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // 업무 수정 명령어 처리
                const handleUpdateCommand = async (originalPrompt, taskInfo) => {
                    // 수정 대상 업무 필터링
                    let relevantTasks = [];
                    if (taskInfo && taskInfo.title) {
                        relevantTasks = appData.tasks.filter(task => 
                            task.title.toLowerCase().includes(taskInfo.title.toLowerCase())
                        );
                    } else {
                        // 제목 정보가 없으면 최근 업무 몇 개만 표시
                        relevantTasks = appData.tasks.slice(-5);
                    }
                    
                    const systemMessage = `
                다음은 수정할 가능성이 있는 업무 목록입니다:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    assignees: t.assignees,
                    columnId: t.columnId,
                    completed: t.completed
                })))}

                사용자 요청: "${originalPrompt}"

                수정할 업무와 변경할 내용을 파악해 다음 JSON 형식으로 응답해주세요:
                {
                "message": "업무 수정 확인 메시지 (한국어)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "update",
                    "payload": {
                        "taskId": "업무ID",
                        "updates": {
                        "title": "새 업무명",
                        "description": "새 설명",
                        "dueDate": "새 마감일",
                        "priority": "새 중요도",
                        "assignees": "새 담당자",
                        "completed": false/true,
                        "columnId": "새 컬럼ID",
                        "tags": ["새 태그1", "새 태그2"]
                        }
                    }
                    }
                ]
                }

                변경할 필드만 포함하고 나머지는 생략하세요.
                `;
                    
                    const response = await janAI.sendPrompt("업무 수정 처리: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // 업무 삭제 명령어 처리
                const handleDeleteCommand = async (originalPrompt, taskInfo) => {
                    // 삭제 대상 업무 필터링
                    let relevantTasks = [];
                    if (taskInfo && taskInfo.title) {
                        relevantTasks = appData.tasks.filter(task => 
                            task.title.toLowerCase().includes(taskInfo.title.toLowerCase())
                        );
                    } else {
                        // 제목 정보가 없으면 최근 업무 몇 개만 표시
                        relevantTasks = appData.tasks.slice(-5);
                    }
                    
                    const systemMessage = `
                다음은 삭제할 가능성이 있는 업무 목록입니다:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    assignees: t.assignees
                })))}

                사용자 요청: "${originalPrompt}"

                삭제할 업무를 파악해 다음 JSON 형식으로 응답해주세요:
                {
                "message": "업무 삭제 확인 메시지 (한국어)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "delete",
                    "payload": {
                        "taskId": "업무ID"
                    }
                    }
                ]
                }

                업무를 여러개 삭제해야 하는 경우 여러 delete 액션을 포함하세요.
                업무를 찾을 수 없으면 "message"에 그 내용을 포함하고 "proposed_actions"는 빈 배열로 설정하세요.
                `;
                    
                    const response = await janAI.sendPrompt("업무 삭제 처리: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // 업무 이동 명령어 처리
                const handleMoveCommand = async (originalPrompt, taskInfo) => {
                    // 이동 대상 업무 필터링
                    let relevantTasks = [];
                    if (taskInfo && taskInfo.title) {
                        relevantTasks = appData.tasks.filter(task => 
                            task.title.toLowerCase().includes(taskInfo.title.toLowerCase())
                        );
                    } else {
                        // 제목 정보가 없으면 최근 업무 몇 개만 표시
                        relevantTasks = appData.tasks.slice(-5);
                    }
                    
                    // 컬럼 정보 제공
                    const columns = appData.columns.map(c => ({
                        id: c.id,
                        title: c.title
                    }));
                    
                    const systemMessage = `
                다음은 이동할 가능성이 있는 업무 목록입니다:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    columnId: t.columnId
                })))}

                가능한 대상 컬럼 목록:
                ${JSON.stringify(columns)}

                사용자 요청: "${originalPrompt}"

                이동할 업무와 대상 컬럼을 파악해 다음 JSON 형식으로 응답해주세요:
                {
                "message": "업무 이동 확인 메시지 (한국어)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "move",
                    "payload": {
                        "taskId": "업무ID",
                        "targetColumnId": "대상컬럼ID"
                    }
                    }
                ]
                }

                업무나 대상 컬럼을 찾을 수 없으면 "message"에 그 내용을 포함하고 "proposed_actions"는 빈 배열로 설정하세요.
                `;
                    
                    const response = await janAI.sendPrompt("업무 이동 처리: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // 업무 정리 명령어 처리
                const handleOrganizeCommand = async (originalPrompt) => {
                    // 정리 대상 업무와 컬럼 정보 제공
                    const columns = appData.columns.map(c => ({
                        id: c.id,
                        title: c.title
                    }));
                    
                    // 명령어에 따라 전체 또는 일부 업무만 제공
                    let tasksToOrganize = appData.tasks;
                    if (originalPrompt.toLowerCase().includes("마감")) {
                        // 마감일 관련 명령이면 마감일이 있는 업무만 필터링
                        tasksToOrganize = appData.tasks.filter(t => t.dueDate);
                    } else if (originalPrompt.toLowerCase().includes("우선순위") || 
                            originalPrompt.toLowerCase().includes("중요도")) {
                        // 우선순위 관련 명령이면 우선순위 정보가 있는 업무만
                        tasksToOrganize = appData.tasks.filter(t => t.priority);
                    }
                    
                    const systemMessage = `
                사용자 요청: "${originalPrompt}"

                다음은 현재 컬럼 목록입니다:
                ${JSON.stringify(columns)}

                다음은 정리할 업무 목록입니다:
                ${JSON.stringify(tasksToOrganize.map(t => ({
                    id: t.id,
                    title: t.title,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    assignees: t.assignees,
                    columnId: t.columnId,
                    completed: t.completed
                })))}

                사용자의 요청에 따라 업무를 정리해주세요. 업무 정리는 다음 작업을 포함할 수 있습니다:
                1. 업무 이동 (move)
                2. 업무 업데이트 (update)
                3. 업무 삭제 (delete)

                필요한 작업들을 파악해 다음 JSON 형식으로 응답해주세요:
                {
                "message": "업무 정리 제안 설명 (한국어)",
                "requires_confirmation": true,
                "proposed_actions": [
                    // 필요한 작업들...
                ]
                }

                액션은 최대 5개까지만 제안하세요.
                `;
                    
                    const response = await janAI.sendPrompt("업무 정리: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // 일반적인 명령어 처리 (유형 분류 실패 시)
                const handleGenericCommand = async (originalPrompt) => {
                    // 작은 모델에게 부담되지 않도록 최소한의 정보만 제공
                    const basicInfo = {
                        taskCount: appData.tasks.length,
                        columnCount: appData.columns.length,
                        columnNames: appData.columns.map(c => c.title)
                    };
                    
                    const systemMessage = `
                현재 업무 관리 앱 정보:
                - 총 업무 수: ${basicInfo.taskCount}개
                - 컬럼 수: ${basicInfo.columnCount}개
                - 컬럼 이름: ${basicInfo.columnNames.join(', ')}

                사용자 요청: "${originalPrompt}"

                사용자의 요청을 이해하고 응답해주세요. 작업이 필요하면 다음 JSON 형식으로 응답하고, 
                단순 질문이면 간단한 정보 응답을 JSON 형식으로 제공해주세요:

                {
                "message": "사용자 요청에 대한 응답 (한국어)",
                "requires_confirmation": false/true,
                "proposed_actions": [] // 필요시 작업 제안
                }

                작업이 필요 없는 단순 응답:
                {
                "message": "요청에 대한 답변 (한국어)",
                "requires_confirmation": false,
                "proposed_actions": []
                }
                `;
                    
                    const response = await janAI.sendPrompt(originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // 마감일 관련 명령어 처리
                    const handleDateCommand = async (originalPrompt, dateInfo) => {
                        // 현재 날짜 기준으로 날짜 필터링 조건 생성
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        
                        // 마감일 조건에 따른 업무 필터링
                        let filteredTasks = [];
                        let conditionDescription = "";
                        
                        switch (dateInfo?.condition) {
                            case 'overdue':
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    return new Date(task.dueDate) < today;
                                });
                                conditionDescription = "마감일이 지난";
                                break;
                                
                            case 'today':
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    const taskDate = new Date(task.dueDate);
                                    return taskDate.getFullYear() === today.getFullYear() &&
                                        taskDate.getMonth() === today.getMonth() &&
                                        taskDate.getDate() === today.getDate();
                                });
                                conditionDescription = "오늘 마감인";
                                break;
                                
                            case 'tomorrow':
                                const tomorrow = new Date(today);
                                tomorrow.setDate(today.getDate() + 1);
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    const taskDate = new Date(task.dueDate);
                                    return taskDate.getFullYear() === tomorrow.getFullYear() &&
                                        taskDate.getMonth() === tomorrow.getMonth() &&
                                        taskDate.getDate() === tomorrow.getDate();
                                });
                                conditionDescription = "내일 마감인";
                                break;
                                
                            case 'thisWeek':
                                const weekEnd = new Date(today);
                                weekEnd.setDate(today.getDate() + (6 - today.getDay())); // 이번 주 일요일
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    const taskDate = new Date(task.dueDate);
                                    return taskDate >= today && taskDate <= weekEnd;
                                });
                                conditionDescription = "이번 주 마감인";
                                break;
                                
                            default:
                                // 기본: 마감일 있는 모든 업무
                                filteredTasks = appData.tasks.filter(task => task.dueDate);
                                conditionDescription = "마감일이 있는";
                                break;
                        }
                        
                        // 작업 유형에 따른 처리
                        const actionType = dateInfo?.action || 'search';
                        
                        if (actionType === 'search') {
                            // 검색 결과 반환
                            const response = {
                                message: `${conditionDescription} 업무 ${filteredTasks.length}개를 찾았습니다.`,
                                requires_confirmation: false,
                                proposed_actions: [
                                    {
                                        type: "info",
                                        payload: {
                                            details: filteredTasks.map(t => ({
                                                id: t.id,
                                                title: t.title,
                                                dueDate: t.dueDate,
                                                priority: t.priority,
                                                columnId: t.columnId,
                                                assignees: t.assignees
                                            }))
                                        }
                                    }
                                ]
                            };
                            
                            handleAIResponse(response);
                        } else if (actionType === 'tag') {
                            // 태그 추가 제안
                            const tagName = originalPrompt.match(/[''"]([^''"]+)[''"]/) ? 
                                            originalPrompt.match(/[''"]([^''"]+)[''"]/) :
                                            originalPrompt.includes('태그') ? 
                                            originalPrompt.split('태그')[1].trim().split(' ')[0] : 
                                            '마감임박';
                                            
                            const actions = filteredTasks.map(task => ({
                                type: "update",
                                payload: {
                                    taskId: task.id,
                                    updates: {
                                        tags: [...(task.tags || []), tagName]
                                    }
                                }
                            }));
                            
                            if (actions.length > 0) {
                                const response = {
                                    message: `${conditionDescription} 업무 ${filteredTasks.length}개에 '${tagName}' 태그를 추가하시겠습니까?`,
                                    requires_confirmation: true,
                                    proposed_actions: actions
                                };
                                
                                handleAIResponse(response);
                            } else {
                                handleAIResponse({
                                    message: `${conditionDescription} 업무가 없습니다.`,
                                    requires_confirmation: false,
                                    proposed_actions: []
                                });
                            }
                        }
                    };
                                        

                // AI 응답 처리 - 공통 함수
                const processAIResponse = (response) => {
                    const aiContent = response?.choices?.[0]?.message?.content;
                    
                    if (!aiContent) {
                        aiResponse.innerHTML = "<div class='ai-error'>AI로부터 유효한 응답을 받지 못했습니다.</div>";
                        return;
                    }
                    
                    // JSON 부분 추출
                    const jsonMatch = aiContent.match(/{[\s\S]*}/);
                    if (jsonMatch) {
                        try {
                            const parsedResponse = JSON.parse(jsonMatch[0]);
                            handleAIResponse(parsedResponse);
                        } catch (parseError) {
                            console.error("AI 응답 JSON 파싱 오류:", parseError);
                            
                            // 파싱 실패시 텍스트 그대로 표시
                            aiResponse.innerHTML = `
                                <div class='ai-error'>응답 형식에 문제가 있습니다. 원본 응답:</div>
                                <div class='ai-response-text'>${utils.escapeHtml(aiContent)}</div>
                            `;
                        }
                    } else {
                        // JSON이 아닌 텍스트 응답 처리
                        aiResponse.innerHTML = `<div class='ai-response-text'>${utils.escapeHtml(aiContent)}</div>`;
                    }
                };

                // AI 응답 처리 및 UI 업데이트
                let storedProposedActions = []; // 확인 대기 중인 작업을 임시 저장

                const handleAIResponse = (response) => {
                    aiResponse.innerHTML = ''; // 이전 응답 지우기
                    storedProposedActions = []; // 이전 액션 제안 초기화

                    const message = response?.message || "AI로부터 메시지를 받지 못했습니다.";
                    const requiresConfirmation = response?.requires_confirmation === true; // 명시적으로 true인지 확인
                    const proposedActions = response?.proposed_actions || [];

                    // 메시지 표시
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'ai-response-text';
                    messageDiv.textContent = message; // textContent로 안전하게 표시
                    aiResponse.appendChild(messageDiv);

                    // 'info' 타입 액션 처리 (정보성 메시지 추가 표시)
                    const infoAction = proposedActions.find(a => a.type === 'info');
                    if (infoAction && infoAction.payload?.details) {
                        const detailsDiv = document.createElement('div');
                        detailsDiv.style.marginTop = '10px';
                        detailsDiv.style.fontSize = '0.9em';
                        detailsDiv.style.opacity = '0.8';
                        
                        if (Array.isArray(infoAction.payload.details)) {
                            detailsDiv.innerHTML = '<strong>관련 업무:</strong><ul>' +
                                infoAction.payload.details.map(taskInfo =>
                                    `<li>${utils.escapeHtml(taskInfo.title || '제목 없음')} ${
                                        taskInfo.dueDate ? `(마감일: ${taskInfo.dueDate})` : ''
                                    } ${
                                        taskInfo.priority ? `(중요도: ${taskInfo.priority})` : ''
                                    }</li>`
                                ).join('') + '</ul>';
                        } else if (typeof infoAction.payload.details === 'string') {
                            detailsDiv.innerHTML = `<strong>정보:</strong> ${utils.escapeHtml(infoAction.payload.details)}`;
                        }
                        aiResponse.appendChild(detailsDiv);
                    }

                    if (requiresConfirmation && proposedActions.length > 0) {
                        // 확인/취소 버튼 추가
                        storedProposedActions = proposedActions; // 실행할 액션 저장

                        const confirmationDiv = document.createElement('div');
                        confirmationDiv.style.marginTop = '15px';
                        confirmationDiv.style.display = 'flex';
                        confirmationDiv.style.gap = '10px';

                        const confirmButton = document.createElement('button');
                        confirmButton.textContent = '확인 (실행)';
                        confirmButton.className = 'ai-btn ai-btn--confirm';
                        confirmButton.onclick = () => {
                            aiResponse.innerHTML = "<div class='ai-thinking'>⏳ 작업을 처리 중입니다...</div>";
                            // 저장된 액션 실행
                            executeProposedAIActions(storedProposedActions);
                            storedProposedActions = []; // 실행 후 초기화
                        };

                        const cancelButton = document.createElement('button');
                        cancelButton.textContent = '취소';
                        cancelButton.className = 'ai-btn ai-btn--cancel ai-btn--secondary';
                        cancelButton.onclick = () => {
                            aiResponse.innerHTML = "<div class='ai-info'>ℹ️ 작업이 취소되었습니다.</div>";
                            storedProposedActions = []; // 취소 시 초기화
                        };

                        confirmationDiv.appendChild(confirmButton);
                        confirmationDiv.appendChild(cancelButton);
                        aiResponse.appendChild(confirmationDiv);
                    } else if (!requiresConfirmation && proposedActions.length === 0 && !infoAction) {
                        // 작업 없음 & 정보 없음 메시지 강조
                        messageDiv.style.fontStyle = 'italic';
                    }
                };

                // 제안된 AI 액션 실행
                const executeProposedAIActions = (actions) => {
                    let performedActions = false;
                    let actionResults = []; // 각 액션의 성공/실패 메시지

                    try {
                        actions.forEach(action => {
                            const { type, payload } = action;
                            let resultMessage = '';
                            
                            try {
                                switch (type) {
                                    case 'add':
                                        if (payload.columnId && payload.title) {
                                            addTask({
                                                columnId: payload.columnId,
                                                title: payload.title,
                                                description: payload.description,
                                                dueDate: payload.dueDate,
                                                priority: payload.priority || 'medium',
                                                assignees: payload.assignees,
                                                tags: payload.tags || []
                                            });
                                            resultMessage = `✅ '${payload.title}' 업무 추가 완료.`;
                                            performedActions = true;
                                        } else {
                                            throw new Error("추가 액션에 필요한 정보가 부족합니다.");
                                        }
                                        break;
                                        
                                    case 'update':
                                        if (payload.taskId && payload.updates) {
                                            const taskIndex = appData.tasks.findIndex(t => t.id === payload.taskId);
                                            if (taskIndex > -1) {
                                                const task = appData.tasks[taskIndex];
                                                updateTask(payload.taskId, { ...task, ...payload.updates });
                                                resultMessage = `✅ '${task.title}' 업무 수정 완료.`;
                                                performedActions = true;
                                            } else {
                                                throw new Error(`ID '${payload.taskId}'의 업무를 찾을 수 없습니다.`);
                                            }
                                        } else {
                                            throw new Error("수정 액션에 필요한 정보가 부족합니다.");
                                        }
                                        break;
                                        
                                    case 'delete':
                                        if (payload.taskId) {
                                            const task = appData.tasks.find(t => t.id === payload.taskId);
                                            if (task) {
                                                const taskTitle = task.title; // 삭제 전 제목 저장
                                                deleteTask(payload.taskId);
                                                resultMessage = `✅ '${taskTitle}' 업무 삭제 완료.`;
                                                performedActions = true;
                                            } else {
                                                throw new Error(`ID '${payload.taskId}'의 업무를 찾을 수 없습니다.`);
                                            }
                                        } else {
                                            throw new Error("삭제 액션에 필요한 정보가 부족합니다.");
                                        }
                                        break;
                                        
                                    case 'move':
                                        if (payload.taskId && payload.targetColumnId) {
                                            const task = appData.tasks.find(t => t.id === payload.taskId);
                                            const column = appData.columns.find(c => c.id === payload.targetColumnId);
                                            
                                            if (task && column) {
                                                moveTask(payload.taskId, payload.targetColumnId);
                                                resultMessage = `✅ '${task.title}' 업무를 '${column.title}' 컬럼으로 이동 완료.`;
                                                performedActions = true;
                                            } else {
                                                throw new Error("이동할 업무 또는 대상 컬럼을 찾을 수 없습니다.");
                                            }
                                        } else {
                                            throw new Error("이동 액션에 필요한 정보가 부족합니다.");
                                        }
                                        break;
                                        
                                    case 'info':
                                        // 정보 액션은 별도 처리 필요 없음
                                        resultMessage = `ℹ️ 정보 조회 완료.`;
                                        break;
                                        
                                    default:
                                        console.warn("알 수 없는 AI 액션 타입:", type);
                                        resultMessage = `⚠️ 알 수 없는 액션 타입 '${type}'`;
                                }
                                
                                actionResults.push(resultMessage);
                            } catch (actionError) {
                                console.error(`Error executing AI action ${type}:`, actionError);
                                actionResults.push(`❌ ${type} 액션 처리 중 오류: ${actionError.message}`);
                            }
                        });

                        if (performedActions) {
                            saveData(); // 모든 액션 처리 후 한 번만 저장
                            renderBoard(); // UI 업데이트
                            
                            // 성공 메시지 표시
                            aiResponse.innerHTML = `<div class='ai-success'>${actionResults.filter(r => r.startsWith('✅') || r.startsWith('ℹ️')).join('<br>')}</div>`;
                            
                            if(actionResults.some(r => r.startsWith('❌') || r.startsWith('⚠️'))) {
                                aiResponse.innerHTML += `<div class='ai-error' style='margin-top: 10px;'><strong>일부 작업 실패:</strong><br>${actionResults.filter(r => r.startsWith('❌') || r.startsWith('⚠️')).join('<br>')}</div>`;
                            }
                        } else {
                            // 실행된 작업이 없을 때
                            if (actionResults.some(r => r.startsWith('❌') || r.startsWith('⚠️'))) {
                                aiResponse.innerHTML = `<div class='ai-error'><strong>작업 실패:</strong><br>${actionResults.filter(r => r.startsWith('❌') || r.startsWith('⚠️')).join('<br>')}</div>`;
                            } else {
                                aiResponse.innerHTML = `<div class='ai-info'>ℹ️ 요청하신 작업이 완료되었습니다 (데이터 변경 없음).</div>`;
                            }
                        }
                    } catch (globalError) {
                        console.error("Error during AI action execution:", globalError);
                        aiResponse.innerHTML = `<div class='ai-error'>⚠️ AI 액션 실행 중 예외 발생: ${utils.escapeHtml(globalError.message)}</div>`;
                    }
                };

                // AI로 업무 정리 기능
                /*const organizeTasksWithAI = async () => {
                    // --- AI 프롬프트 예시 수정: 작은 모델에서 더 잘 이해할 수 있도록 명확화 ---
                    const organizePrompt = `
                    업무 정리 요청:
                    1. 마감일(dueDate)이 오늘 날짜보다 이전인 모든 업무를 찾아서 중요도(priority)를 'high'로 변경해주세요.
                    2. 마감일(dueDate)이 오늘 날짜와 같은 모든 업무를 찾아서 '오늘마감' 태그(tags)를 추가해주세요. (기존 태그 유지)
                    3. 완료된(completed: true) 업무가 있다면 알려주세요. (정렬은 사용자가 직접 하도록 유도)
                    `;
                    await processAICommand(organizePrompt);
                };*/
            // --- Modal Handling ---
            // Store reference to the element that was focused before opening the modal
            let elementFocusedBeforeModal;

            const openTaskModal = (mode = 'add', columnId = null, taskId = null) => {
                elementFocusedBeforeModal = document.activeElement; // Store focus

                taskForm.reset();
                tagsContainer.innerHTML = '';
                currentTags = [];
                taskModal.setAttribute('aria-hidden', 'false'); // Make modal accessible

                const today = new Date().toISOString().split('T')[0];
                taskForm.taskDueDate.value = today; // Default due date
                taskForm.taskPriority.value = 'medium'; // Default priority

                if (mode === 'edit' && taskId) {
                    const task = getTaskDataById(taskId);
                    if (task) {
                        modalTitle.textContent = '업무 수정';
                        taskForm.taskId.value = task.id;
                        taskForm.columnId.value = task.columnId;
                        taskForm.taskTitle.value = task.title;
                        taskForm.taskDescription.value = task.description || '';
                        taskForm.taskDueDate.value = task.dueDate || ''; // Allow empty date
                        taskForm.taskAssignees.value = task.assignees || '';
                        taskForm.taskPriority.value = task.priority || 'medium';
                        if (task.tags && task.tags.length > 0) {
                            currentTags = [...task.tags];
                            renderTags();
                        }
                    } else {
                        console.error("업무 수정 오류: ID를 찾을 수 없음", taskId);
                        utils.showFeedback("수정하려는 업무를 찾을 수 없습니다.", 'error');
                        taskModal.setAttribute('aria-hidden', 'true'); // Hide if error
                        return; // Don't open modal
                    }
                } else {
                    const columnName = getColumnTitleElement(columnId)?.textContent || '새';
                    modalTitle.textContent = `${columnName} 업무 추가`;
                    taskForm.taskId.value = '';
                    taskForm.columnId.value = columnId;
                     taskForm.taskDueDate.value = ''; // Start with empty date for new tasks
                }

                taskModal.classList.add('visible');
                requestAnimationFrame(() => { // Wait for display:flex to apply
                    taskModal.classList.add('modal--visible');
                    taskForm.taskTitle.focus(); // Set focus to the first input
                     // Basic focus trap concept (needs more robust implementation for production)
                     // Add keydown listener to modal content to trap focus
                });
            };

            const closeModal = () => {
                // 1. 포커스 되돌리기 (가장 먼저 수행)
                if (elementFocusedBeforeModal) {
                    elementFocusedBeforeModal.focus();
                }

                taskModal.classList.remove('modal--visible');

                // 2. aria-hidden 설정 (포커스 이동 후)
                 taskModal.setAttribute('aria-hidden', 'true');

                 // Wait for transition to finish before removing 'visible' (display: none)
                  // The timeout should match the CSS transition duration
                 setTimeout(() => {
                     taskModal.classList.remove('visible');
                 }, 300); // Match CSS transition duration
             };

            
            const openDetailModal = (taskId) => {
                elementFocusedBeforeModal = document.activeElement;
                const task = getTaskDataById(taskId);
                if (!task) {
                    console.error("업무 상세 보기 오류: ID를 찾을 수 없음", taskId);
                    utils.showFeedback("표시하려는 업무를 찾을 수 없습니다.", 'error');
                    return;
                }

                // Use textContent or utils.escapeHtml for security
                detailContent.innerHTML = `
                    <h3 id="taskDetailTitle">${utils.escapeHtml(task.title)}</h3>
                    <p><strong>상태:</strong> ${task.completed ? '완료' : '진행중'}</p>
                    <p><strong>중요도:</strong> ${task.priority || '보통'}</p>
                    <p><strong>마감일:</strong> ${utils.formatDueDateForDisplay(task.dueDate)} (${task.dueDate || '미지정'})</p>
                    <p><strong>담당자:</strong> ${utils.escapeHtml(task.assignees || '미지정')}</p>
                    ${task.tags && task.tags.length > 0 ?
                        `<p><strong>태그:</strong> ${task.tags.map(t => `<span class="task__tag">${utils.escapeHtml(t)}</span>`).join(' ')}</p>` : ''}
                    <p><strong>설명:</strong></p>
                    <p style="white-space: pre-wrap; word-wrap: break-word;">${utils.escapeHtml(task.description || '없음')}</p>
                `;

                detailModal.setAttribute('aria-hidden', 'false');
                detailModal.classList.add('visible');
                requestAnimationFrame(() => {
                    detailModal.classList.add('modal--visible');
                    detailModal.querySelector('.modal__close').focus(); // Focus close button
                });
            };

            const closeDetailModal = () => {
                detailModal.classList.remove('modal--visible');
                detailModal.setAttribute('aria-hidden', 'true');
                setTimeout(() => {
                    detailModal.classList.remove('visible');
                     if (elementFocusedBeforeModal) {
                        elementFocusedBeforeModal.focus();
                    }
                }, 300);
            };

            // --- Tag Management ---
            const addTag = (tagText) => {
                const tag = tagText.trim();
                if (tag && !currentTags.includes(tag)) {
                    if (currentTags.length >= 10) { // Limit tags?
                        utils.showFeedback("태그는 최대 10개까지 추가할 수 있습니다.", 'warning');
                        return;
                    }
                    currentTags.push(tag);
                    renderTags();
                }
                tagInput.value = ''; // Clear input after adding
            };

            const removeTag = (tagIndex) => {
                if (tagIndex >= 0 && tagIndex < currentTags.length) {
                     const removedTag = currentTags.splice(tagIndex, 1)[0];
                     renderTags();
                     // utils.showFeedback(`'${removedTag}' 태그 삭제됨.`); // Maybe too noisy
                }
            };

            const renderTags = () => {
                tagsContainer.innerHTML = '';
                if (currentTags.length === 0) {
                    // Optional: Show placeholder text when no tags
                    // tagsContainer.innerHTML = '<p style="font-style: italic; color: var(--text-secondary-color);">태그가 없습니다.</p>';
                    return;
                }
                currentTags.forEach((tag, index) => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'form-group__tag';
                    tagEl.textContent = tag; // Set text content directly

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button'; // Prevent form submission
                    removeBtn.className = 'form-group__tag-remove';
                    removeBtn.innerHTML = '×';
                    removeBtn.dataset.tagIndex = index;
                    removeBtn.setAttribute('aria-label', `${tag} 태그 삭제`);
                    removeBtn.addEventListener('click', () => removeTag(index)); // Add listener here

                    tagEl.appendChild(removeBtn);
                    tagsContainer.appendChild(tagEl);
                });
            };

            // --- Drag and Drop ---
            const handleDragStart = (e) => {
                // Check if dragging is initiated from a valid handle or the task itself
                // For example, prevent drag start if clicking on input/button inside task
                if (e.target.closest('input, button, textarea, select')) {
                    e.preventDefault();
                    return;
                }
                draggedTask = e.target;
                setTimeout(() => draggedTask.classList.add('task--dragging'), 0);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggedTask.dataset.taskId); // Required for Firefox
            };

            const handleDragEnd = () => {
                if (draggedTask) {
                    draggedTask.classList.remove('task--dragging');
                }
                removePlaceholder(); // Ensure placeholder is removed
                board.querySelectorAll('.column__content--drag-over').forEach(col => {
                    col.classList.remove('column__content--drag-over');
                });
                draggedTask = null;
            };

            const handleDragOver = (e) => {
                e.preventDefault(); // Necessary to allow drop
                if (!draggedTask) return;
                e.dataTransfer.dropEffect = 'move';

                const columnContent = e.target.closest('.column__content');
                if (!columnContent) return;

                columnContent.classList.add('column__content--drag-over'); // Highlight column

                const afterElement = getDragAfterElement(columnContent, e.clientY);
                updatePlaceholder(columnContent, afterElement);
            };

            const handleDragLeave = (e) => {
                const columnContent = e.target.closest('.column__content');
                // Check if the mouse is truly leaving the column content area
                if (columnContent && !columnContent.contains(e.relatedTarget)) {
                    columnContent.classList.remove('column__content--drag-over');
                    removePlaceholder();
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                if (!draggedTask) return;
                
                const taskId = draggedTask.dataset.taskId;
                // 대상 컬럼 ID 획득
                let targetColumnId;
                if (e.currentTarget.dataset.columnId) {
                    // 메인 대시보드 컬럼의 경우 dataset.columnId 속성 사용
                    targetColumnId = e.currentTarget.dataset.columnId;
                } else {
                    // PGM 하위 컬럼의 경우 ID에서 추출 (예: "AVI-red-content" -> "AVI-red")
                    const contentElId = e.currentTarget.id;
                    if (contentElId && contentElId.endsWith('-content')) {
                        targetColumnId = contentElId.replace('-content', '');
                    }
                }
                
                if (!targetColumnId) {
                    console.error("Drop target column ID could not be determined");
                    return;
                }
                
                // 다른 컬럼으로 이동시키는 함수 호출
                moveTask(taskId, targetColumnId);
                
                // 드래그 오버 클래스 제거
                e.currentTarget.classList.remove('column__content--drag-over');
            };

            const getDragAfterElement = (container, y) => {
                const draggableElements = [...container.querySelectorAll('.task:not(.task--dragging):not(.task--placeholder)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            };

            // Placeholder functions
            const createPlaceholder = () => {
                if (!dragPlaceholder) {
                    dragPlaceholder = document.createElement('div');
                    dragPlaceholder.className = 'task task--placeholder';
                    // Match height roughly to the dragged task?
                    if (draggedTask) {
                         dragPlaceholder.style.height = `${draggedTask.offsetHeight}px`;
                    }
                }
                return dragPlaceholder;
            };

            const removePlaceholder = () => {
                if (dragPlaceholder && dragPlaceholder.parentNode) {
                    dragPlaceholder.parentNode.removeChild(dragPlaceholder);
                }
                // dragPlaceholder = null; // Don't nullify, reuse the element
            };

            const updatePlaceholder = (container, afterElement) => {
                removePlaceholder(); // Remove from previous position first
                const placeholder = createPlaceholder();
                if (afterElement) {
                    container.insertBefore(placeholder, afterElement);
                } else {
                    container.appendChild(placeholder); // Append if no element after
                }
            };


            // --- Context Menu ---
            const showColumnMenu = (buttonElement, columnId) => {
                closeColumnMenu(); // 기존 메뉴 닫기

                currentMenu = document.createElement('div');
                currentMenu.className = 'menu';
                currentMenu.setAttribute('role', 'menu');

                const createMenuItem = (text, action, ariaLabel) => {
                    const item = document.createElement('div');
                    item.className = 'menu__item';
                    item.textContent = text;
                    item.setAttribute('role', 'menuitem');
                    item.tabIndex = -1; // Make focusable by script if needed
                    item.onclick = () => {
                        action();
                        closeColumnMenu();
                    };
                    if (ariaLabel) item.setAttribute('aria-label', ariaLabel);
                    return item;
                };

                //currentMenu.appendChild(createMenuItem('완료된 항목 삭제', () => deleteCompletedTasks(columnId)));
                //currentMenu.appendChild(createMenuItem('전체 삭제', () => deleteAllTasksFromColumn(columnId), '경고: 해당 컬럼의 모든 항목을 삭제합니다'));

                const separator = document.createElement('div');
                separator.className = 'menu__separator';
                separator.setAttribute('role', 'separator');
                currentMenu.appendChild(separator);

                currentMenu.appendChild(createMenuItem('텍스트 파일로 내보내기', () => exportColumnToText(columnId)));

                document.body.appendChild(currentMenu);

                // Positioning
                const btnRect = buttonElement.getBoundingClientRect(); // <-- 변경: 기준 요소를 buttonElement로
                const menuRect = currentMenu.getBoundingClientRect(); // 메뉴 자체의 크기 (변경 없음)
                let top = btnRect.bottom + window.scrollY + 2;
                let left = btnRect.left + window.scrollX;

                // Adjust if menu goes off-screen
                if (left + menuRect.width > window.innerWidth - 10) {
                    left = btnRect.right + window.scrollX - menuRect.width;
                }
                if (top + menuRect.height > window.innerHeight - 10) {
                    top = btnRect.top + window.scrollY - menuRect.height - 2;
                }

                currentMenu.style.top = `${Math.max(0, top)}px`;
                currentMenu.style.left = `${Math.max(0, left)}px`;

                requestAnimationFrame(() => {
                     currentMenu.classList.add('menu--visible');
                     currentMenu.querySelector('.menu__item')?.focus(); // Focus first item?
                });

                // --- 외부 클릭 및 ESC 키 리스너 추가 (handleClickOutsideMenu에 buttonElement 전달) ---
                setTimeout(() => {
                    // document.addEventListener('click', handleClickOutsideMenu, { capture: true, once: true }); // 이전 코드
                    // 클릭 이벤트 핸들러에 buttonElement 정보도 함께 전달
                    document.addEventListener('click', (e) => handleClickOutsideMenu(e, buttonElement), { capture: true, once: true });
                    document.addEventListener('keydown', handleMenuKeyDown, { capture: true }); // Keydown 핸들러는 변경 필요 없을 수 있음
                }, 0);
            };
            const closeColumnMenu = () => {
                if (currentMenu) {
                    currentMenu.classList.remove('menu--visible');
                     document.removeEventListener('keydown', handleMenuKeyDown, { capture: true });
                    // Remove from DOM after transition
                    currentMenu.addEventListener('transitionend', () => {
                        currentMenu?.remove(); // Check if still exists
                        currentMenu = null;
                    }, { once: true });
                }
                 document.removeEventListener('click', handleClickOutsideMenu, { capture: true }); // Ensure listener removed
            };

            const handleClickOutsideMenu = (event) => {
                if (currentMenu && !currentMenu.contains(event.target) && !event.target.closest('.action-btn--menu')) {
                    closeColumnMenu();
                } else {
                    // If click was inside menu, re-add listener (because of {once:true})
                     // Or better: don't use {once:true} and remove listener explicitly in closeColumnMenu
                     // Let's stick with the current logic for now, but it's less robust.
                }
            };

            const handleMenuKeyDown = (event) => {
                 if (!currentMenu) return;
                 if (event.key === 'Escape') {
                     closeColumnMenu();
                     // Optionally return focus to the menu button
                     // event.target.closest('.column__actions').querySelector('.action-btn--menu').focus();
                 }
                 // Add arrow key navigation if desired
            };

            // --- Export ---
            const exportColumnToText = (columnId) => {
                const tasksToExport = appData.tasks.filter(task => task.columnId === columnId)
                                            .sort((a, b) => (new Date(a.dueDate || '9999-12-31')) - (new Date(b.dueDate || '9999-12-31')));
                if (tasksToExport.length === 0) {
                    utils.showFeedback('내보낼 작업이 없습니다.');
                    return;
                }

                const columnTitle = getColumnTitleElement(columnId)?.textContent || columnId;
                let text = `== ${columnTitle} ==\nExported on: ${new Date().toLocaleString('ko-KR')}\n\n`;
                tasksToExport.forEach(task => {
                    text += `[${task.completed ? 'x' : ' '}] ${task.title}\n`;
                    text += `   - 중요도: ${task.priority || '보통'}\n`;
                    text += `   - 마감일: ${utils.formatDueDateForDisplay(task.dueDate)} (${task.dueDate || '미지정'})\n`;
                    text += `   - 담당자: ${task.assignees || '미지정'}\n`;
                    if (task.tags && task.tags.length > 0) {
                        text += `   - 태그: ${task.tags.join(', ')}\n`;
                    }
                    if (task.description) {
                        text += `   - 설명:\n     ${task.description.replace(/\n/g, '\n     ')}\n`; // Indent description lines
                    }
                    text += `\n`;
                });

                try {
                    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const filename = columnTitle.replace(/[^a-z0-9_\-가-힣]/gi, '_');
                    a.download = `${filename}_업무목록_${new Date().toISOString().split('T')[0]}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    utils.showFeedback(`${columnTitle} 목록을 파일로 내보냈습니다.`);
                } catch(e) {
                    console.error("파일 내보내기 오류:", e);
                    utils.showFeedback("파일 내보내기 중 오류 발생", "error");
                    // Fallback: show text in a new window/tab
                    const newWindow = window.open();
                    newWindow.document.write('<pre>' + utils.escapeHtml(text) + '</pre>');
                }
            };

            // --- Search/Filter ---
            const filterTasks = (searchTerm) => {
                const term = searchTerm.toLowerCase().trim();
                const allTasks = board.querySelectorAll('.task');
                let visibleCount = 0;

                allTasks.forEach(taskEl => {
                    // Ignore placeholder during filtering
                    if (taskEl.classList.contains('task--placeholder')) return;

                    const taskId = taskEl.dataset.taskId;
                    const task = getTaskDataById(taskId);
                    let isVisible = false;

                    if (!task) {
                        isVisible = false; // Hide if task data not found
                    } else if (term === '') {
                        isVisible = true; // Show all if search is empty
                    } else {
                        // Search in title, description, assignees, tags
                        const searchableText = [
                            task.title,
                            task.description || '',
                            task.assignees || '',
                            (task.tags || []).join(' ')
                        ].join(' ').toLowerCase();
                        isVisible = searchableText.includes(term);
                    }

                    taskEl.style.display = isVisible ? '' : 'none';
                    if (isVisible) visibleCount++;
                });

                 // Optionally update column counters based on visible tasks? (Might be confusing)
                 // Update empty states based on visible tasks per column
                 appData.columns.forEach(col => {
                     const contentEl = getColumnContentElement(col.id);
                     if (contentEl) {
                         const visibleTasksInColumn = contentEl.querySelectorAll('.task:not([style*="display: none"])').length;
                         const emptyState = contentEl.querySelector('.empty-state');
                         if (visibleTasksInColumn === 0 && !emptyState && term !== '') { // Only show empty state during active search
                            const searchEmptyState = createEmptyState();
                            searchEmptyState.textContent = `'${term}' 검색 결과 없음`;
                            contentEl.appendChild(searchEmptyState);
                         } else if ((visibleTasksInColumn > 0 || term === '') && emptyState) {
                             emptyState.remove();
                         }
                         // Restore original empty state if search is cleared and column is truly empty
                         else if (term === '' && appData.tasks.filter(t=> t.columnId === col.id).length === 0 && !emptyState) {
                              contentEl.appendChild(createEmptyState());
                         }
                     }
                 });
            };

            // filterTasks 함수 정의 바로 아래에 debouncedFilterTasks 선언 추가
            const debouncedFilterTasks = utils.debounce(filterTasks, 300);


            // --- Form Handling ---
            const handleFormSubmit = (event) => {
                event.preventDefault();
                const formData = new FormData(taskForm);
                const taskId = formData.get('taskId');
                const taskData = {
                    columnId: formData.get('columnId'),
                    title: formData.get('taskTitle').trim(),
                    description: formData.get('taskDescription').trim(),
                    dueDate: formData.get('taskDueDate') || null, // Store as null if empty
                    assignees: formData.get('taskAssignees').trim(),
                    priority: formData.get('taskPriority'),
                    tags: [...currentTags] // Get tags from the current modal state
                };

                if (!taskData.title) {
                    utils.showFeedback('업무명을 입력해주세요.', 'warning');
                    taskForm.taskTitle.focus();
                    return;
                }
                // Basic date validation (optional)
                if (taskData.dueDate && isNaN(new Date(taskData.dueDate).getTime())) {
                    utils.showFeedback('유효하지 않은 날짜 형식입니다.', 'warning');
                    taskForm.taskDueDate.focus();
                    return;
                }

                if (taskId) {
                    updateTask(taskId, taskData);
                } else {
                    addTask(taskData);
                     utils.showFeedback(`'${taskData.title}' 업무 추가됨.`);
                }
                
                closeModal();
            };

            // --- Event Delegation Handler ---
            const handleBoardClick = (event) => {
                const target = event.target;
                const menuButton = target.closest('.action-btn--menu');
                const columnEl = target.closest('.column'); // 컬럼 요소 찾기 (기존과 동일)

                // --- Column Actions ---
                if (columnEl) {
                    const columnId = columnEl.dataset.columnId;
                    // Add Task Button
                    if (target.matches('.action-btn--add')) {
                        openTaskModal('add', columnId);
                        return;
                    }
                    // Column Menu Button// menuButton을 찾았는지 확인
                    // showColumnMenu 호출 시 event 대신 menuButton (클릭된 버튼)을 전달
                    if (menuButton) { 
                    showColumnMenu(menuButton, columnId); // <-- event 대신 menuButton 전달
                    return; 
                    }
                    // Column Title (handled by dblclick listener on titleEl)
                }

                // --- Task Actions ---
                const taskEl = target.closest('.task');
                if (taskEl) {
                    const taskId = taskEl.dataset.taskId;
                    const actionTarget = target.closest('[data-action]');
                    const action = actionTarget?.dataset.action;

                    switch(action) {
                        case 'deleteTask':
                            const task = getTaskDataById(taskId);
                            if (task && confirm(`'${task.title}' 업무를 삭제하시겠습니까?`)) {
                                deleteTask(taskId);
                            }
                            break;
                        case 'toggleComplete':
                            // Ensure the click was directly on the checkbox itself
                            if (target.matches('.task__checkbox')) {
                                toggleComplete(taskId);
                            }
                            break;
                        case 'openDetail':
                             // Open detail modal when clicking title or general task area (but not checkbox/delete)
                             if (!target.matches('.task__checkbox') && !target.matches('.task__delete-btn')) {
                                 openDetailModal(taskId);
                             }
                            break;
                         // Double-click to edit is handled by a separate listener on the task element itself
                    }
                    return; // Stop further processing if a task action was handled
                }

                // --- Tag Remove Button (in Modal) ---
                 // This needs to be handled differently as it's outside the board delegate
                 // We added direct listener in renderTags
            };


            // --- Keyboard Shortcuts ---
            const handleKeyDown = (event) => {
                // Ctrl+Enter / Cmd+Enter to submit form when modal is open
                 const isModalOpen = taskModal.classList.contains('visible');
                 const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                 const modKeyPressed = isMac ? event.metaKey : event.ctrlKey;

                if (isModalOpen && modKeyPressed && event.key === 'Enter') {
                     // Check if focus is inside the textarea, if so, allow default newline behavior
                     if (document.activeElement === taskForm.taskDescription) {
                         return; // Allow newline in textarea
                     }
                    event.preventDefault(); // Prevent default newline in other inputs
                    const submitBtn = taskForm.querySelector('button[type="submit"]');
                    if (submitBtn) submitBtn.click();
                    return;
                }

                // Escape to close modals or menus
                if (event.key === 'Escape') {
                     if (currentMenu) {
                         closeColumnMenu();
                         // Optionally return focus to the menu button
                         // event.target.closest('.column__actions').querySelector('.action-btn--menu').focus();
                     }
                    if (taskModal.classList.contains('visible')) {
                         closeModal();
                         return;
                     }
                    if (detailModal.classList.contains('visible')) {
                         closeDetailModal();
                         return;
                     }
                    if (aiInterface.classList.contains('active')) {
                         aiInterface.classList.remove('active');
                         aiInterface.setAttribute('aria-hidden', 'true');
                         // TODO: Return focus to AI toggle button?
                         return;
                     }
                     // Close column title input if active
                     const activeInput = document.querySelector('.column__title-input');
                     if (activeInput) {
                         activeInput.blur(); // Trigger blur to cancel/save
                     }
                    return;
                }

                // Enter in tag input to add tag
                if (document.activeElement === tagInput && event.key === 'Enter') {
                    event.preventDefault(); // Prevent form submission
                    if (tagInput.value.trim()) {
                        addTag(tagInput.value);
                    }
                }
            };

              return { // Expose what's needed by GLOBAL functions and event listeners
                 init,
                 closeModal,
                 closeDetailModal,
                 openTaskModal,
                 renderPgmHistory, // Needed by tabManager
                 // Expose functions needed by the *global* render/task functions
                 createTaskElement, // Needed by renderSingleTask, rerenderSingleTask
                 getTaskDataById,   // Needed by rerenderSingleTask and potentially others
                 updateColumnCounter, // Needed by global task functions
                 renderBoard,       // Needed for error recovery in moveTask
                 // Expose data needed by global task functions
                 appData,
                 // Also expose AI response handler if it needs to call global executeProposedAIActions
                 // handleAIResponse, // Keep AI handlers inside app for now
                };

        })(utils); // Pass utils object

        // --- 전역 헬퍼 함수 정의 ---
        // Define getColumnContentElement globally, BEFORE functions that use it
        const getColumnContentElement = (id) => document.getElementById('board')?.querySelector(`.column__content[data-column-id="${id}"]`);

        // Define getPgmSubColumnContentElement globally
        const getPgmSubColumnContentElement = (subColumnId) => document.getElementById(`${subColumnId}-content`);

        // Define createEmptyState globally
        const createEmptyState = () => {
            const emptyState = document.createElement('div');
            emptyState.className = 'empty-state';
            emptyState.textContent = '업무가 없습니다';
            return emptyState;
        };

        // --- 단일 태스크 렌더링 함수들 (Global) ---
        const renderSingleTask = (task) => {
            console.log(`[renderSingleTask] Called for task: ${task.id} in column: ${task.columnId}`); // 로그 추가
            // 수정: PGM 컬럼도 처리할 수 있도록 수정
            const pgmColumns = ['AVI-red', 'AVI-yellow', 'ATTACH-black', 'ATTACH-pink'];
            const isPgmColumn = pgmColumns.includes(task.columnId);
            
            let columnContent;
            if (isPgmColumn) {
                // PGM 컬럼인 경우 해당 서브컬럼 콘텐츠 요소 획득
                columnContent = getPgmSubColumnContentElement(task.columnId);
                console.log(`[renderSingleTask] Task is for PGM column: ${task.columnId}, container found:`, !!columnContent);
            } else {
                // 메인 대시보드 컬럼인 경우 기존 함수 사용
                columnContent = getColumnContentElement(task.columnId);
                console.log(`[renderSingleTask] Task is for Dashboard column: ${task.columnId}, container found:`, !!columnContent);
            }
            
            if (!columnContent) {
                console.warn(`[renderSingleTask] 컬럼 콘텐츠 요소를 찾을 수 없음 (ID: ${task.columnId}, isPGM: ${isPgmColumn})`);
                return;
            }

            // Rely on updateColumnCounter to handle empty state

            const taskEl = app.createTaskElement(task); // Use exposed app.createTaskElement
            // 빈 상태 제거
            const emptyState = columnContent.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
            columnContent.appendChild(taskEl);
            console.log(`[renderSingleTask] Successfully rendered task ${task.id} to column ${task.columnId}`);
            
            // 대시보드 카운터 업데이트 (PGM 컬럼은 카운터가 없음)
            if (!isPgmColumn && typeof app.updateColumnCounter === 'function') {
                app.updateColumnCounter(task.columnId);
            }
        };

        const rerenderSingleTask = (taskId) => {
            const task = app.getTaskDataById(taskId); // Use exposed app.getTaskDataById
            if (!task) return; // 태스크 데이터가 없으면 종료

            // PGM 컬럼과 메인 대시보드 컬럼 모두에서 요소를 찾도록 수정
            const existingTaskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
            if (!existingTaskEl) {
                 // 요소가 없을 경우 특별한 처리는 하지 않음 (updateTask 등에서 호출 시 이미 확인됨)
                 console.warn(`[rerenderSingleTask] Task element not found for ID: ${taskId}`);
                 return;
            }

            const newTaskEl = app.createTaskElement(task); // Use exposed app.createTaskElement
            existingTaskEl.replaceWith(newTaskEl);
        };

        // --- Task Management (Global) ---
        const addTask = async (taskData) => {
            const newTask = { id: utils.generateId(), completed: false, priority: 'medium', ...taskData };
            try {
                const response = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(newTask) });
                if (!response.ok) { const errorBody = await response.text(); throw new Error(`태스크 추가 실패 (${response.status}): ${errorBody}`); }
                const addedTask = await response.json();
                console.log('[addTask] Server returned task:', JSON.stringify(addedTask));

                // 로컬 데이터 업데이트 전 appData 확인
                if (!app || !app.appData || !Array.isArray(app.appData.tasks)) {
                     console.error('[addTask] app.appData.tasks is not available or not an array!');
                     alert("데이터 저장 및 화면 업데이트에 실패했습니다. (appData 오류)");
                     return;
                }
                app.appData.tasks.push(addedTask); // 이제 안전하게 로컬 데이터 추가

                const pgmColumns = ['AVI-red', 'AVI-yellow', 'ATTACH-black', 'ATTACH-pink'];
                const intendedColumnId = addedTask.columnId; // 서버 응답 기준 ID 사용
                console.log(`[addTask] Intended column for new task: ${intendedColumnId}`);

                if (pgmColumns.includes(intendedColumnId)) {
                    // PGM 컬럼인 경우: DOM 직접 조작
                    console.log(`[addTask] Column ${intendedColumnId} is PGM. Manipulating DOM directly.`);
                    const subColumnContent = getPgmSubColumnContentElement(intendedColumnId);
                    if (subColumnContent) {
                        const emptyState = subColumnContent.querySelector('.empty-state');
                        if (emptyState) emptyState.remove(); // 빈 상태 메시지 제거
                        const taskEl = app.createTaskElement(addedTask);
                        subColumnContent.appendChild(taskEl);
                    } else {
                        console.warn(`[addTask] PGM sub-column content element not found for ID: ${intendedColumnId}`);
                    }
                } else {
                    // 메인 대시보드 컬럼인 경우: renderSingleTask 호출
                    console.log(`[addTask] Column ${intendedColumnId} is Dashboard. Calling renderSingleTask.`);
                    renderSingleTask(addedTask); // 이 함수는 내부적으로 getColumnContentElement를 사용 (대시보드 전용)
                    if (typeof app.updateColumnCounter === 'function') {
                         app.updateColumnCounter(intendedColumnId); // 추가된 대시보드 컬럼 카운터 업데이트
                    } else {
                         console.error('[addTask] app.updateColumnCounter function not found!');
                    }
                }
                console.log(`[addTask] Finished for ${addedTask.id}`);

            } catch (error) { console.error("태스크 추가 오류:", error); alert("태스크 추가에 실패했습니다: " + error.message); }
        };

        const updateTask = async (taskId, updatedData) => {
            let payload = { ...updatedData };
            // currentTags는 모달 스코프 내에서 관리되므로, 여기서는 updatedData에 이미 포함된 것을 사용한다고 가정
            // 또는 handleFormSubmit에서 tags를 포함하여 전달해야 함.
            // 여기서는 payload에 tags가 있다고 가정하고 진행.

            const taskIndex = app.appData.tasks.findIndex(task => task.id === taskId); // Use exposed app.appData - OK
            if (taskIndex === -1) {
                console.error(`[updateTask] Task not found in appData with ID: ${taskId}`);
                return;
            }
            const originalColumnId = app.appData.tasks[taskIndex].columnId; // 원래 컬럼 ID 저장
            const newColumnId = payload.columnId || originalColumnId; // 업데이트될 컬럼 ID

            try {
                const response = await fetch(`/api/tasks/${taskId}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.text(); throw new Error(`태스크 수정 실패 (${response.status}): ${errorBody}`); }
                const returnedTask = await response.json(); // 서버 응답 받기

                // 서버 응답 기반으로 로컬 데이터 업데이트
                app.appData.tasks[taskIndex] = { ...app.appData.tasks[taskIndex], ...returnedTask }; // 서버 응답으로 덮어쓰기
                const updatedTask = app.appData.tasks[taskIndex]; // 업데이트된 태스크 정보

                // --- 수정: PGM 히스토리 탭 또는 메인 보드 갱신 로직 ---
                const pgmColumns = ['AVI-red', 'AVI-yellow', 'ATTACH-black', 'ATTACH-pink'];
                const isOriginalPgm = pgmColumns.includes(originalColumnId);
                const isNewPgm = pgmColumns.includes(updatedTask.columnId);

                console.log(`[updateTask] Task ${taskId} updated. Original Col: ${originalColumnId} (PGM: ${isOriginalPgm}), New Col: ${updatedTask.columnId} (PGM: ${isNewPgm})`);

                // Case 1: 컬럼 이동 없음
                if (originalColumnId === updatedTask.columnId) {
                    if (isNewPgm) {
                        // PGM 내에서 내용만 변경: rerenderSingleTask 사용 (PGM 요소도 찾아 교체함)
                        console.log(`[updateTask] PGM task content updated. Calling rerenderSingleTask.`);
                        rerenderSingleTask(taskId);
                    } else {
                        // Dashboard 내에서 내용만 변경: rerenderSingleTask 사용
                        console.log(`[updateTask] Dashboard task content updated. Calling rerenderSingleTask.`);
                        rerenderSingleTask(taskId);
                        // 카운터는 변경 없으므로 업데이트 불필요
                    }
                }
                // Case 2: 컬럼 이동 발생
                else {
                    console.log(`[updateTask] Column move detected: ${originalColumnId} -> ${updatedTask.columnId}`);
                    // 기존 위치에서 DOM 요소 제거
                    const existingTaskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (existingTaskEl) {
                        const sourceColumnContent = existingTaskEl.parentElement;
                        existingTaskEl.remove();
                        // 이전 컬럼 처리 (Empty State 및 카운터)
                        if (isOriginalPgm) {
                             if (sourceColumnContent && sourceColumnContent.children.length === 0) {
                                sourceColumnContent.appendChild(createEmptyState());
                             }
                        } else {
                             app.updateColumnCounter(originalColumnId); // Dashboard 카운터 업데이트
                             if (sourceColumnContent && !sourceColumnContent.querySelector('.task:not([style*="display: none"])')) {
                                // If dashboard column is now empty (considering filters), add empty state if not present
                                if (!sourceColumnContent.querySelector('.empty-state')) {
                                    sourceColumnContent.appendChild(createEmptyState());
                                }
                             }
                        }
                    }

                    // 새 위치에 DOM 요소 추가
                    const newTaskEl = app.createTaskElement(updatedTask);
                    if (isNewPgm) {
                        // PGM으로 이동: 새 PGM 컬럼에 추가
                        const targetPgmContent = getPgmSubColumnContentElement(updatedTask.columnId);
                        if (targetPgmContent) {
                             const emptyState = targetPgmContent.querySelector('.empty-state');
                             if (emptyState) emptyState.remove();
                             targetPgmContent.appendChild(newTaskEl);
                        }
                    } else {
                        // Dashboard로 이동: 새 Dashboard 컬럼에 추가
                        const targetDashContent = getColumnContentElement(updatedTask.columnId);
                        if (targetDashContent) {
                            const emptyState = targetDashContent.querySelector('.empty-state');
                            if (emptyState) emptyState.remove();
                            targetDashContent.appendChild(newTaskEl);
                            app.updateColumnCounter(updatedTask.columnId); // Dashboard 카운터 업데이트
                        }
                    }
                }
                // ---------------------------------------------------
            } catch (error) {
                 console.error("태스크 수정 오류:", error); alert("태스크 수정에 실패했습니다: " + error.message);
                 // 오류 발생 시 전체 렌더링으로 복구 시도 (선택적)
                 app.renderBoard();
                 app.renderPgmHistory();
            }
        };

         const deleteTask = async (taskId) => {
             console.log(`[deleteTask] Initiated for task ID: ${taskId}`);
             const taskIndex = app.appData.tasks.findIndex(task => task.id === taskId);
             if (taskIndex === -1) {
                 console.error(`[deleteTask] Task ID ${taskId} not found in local appData.tasks.`);
                 alert("오류: 삭제하려는 태스크를 찾을 수 없습니다.");
                 return;
             }

             // Optimistic UI: Remove from local data and DOM first
             const deletedTask = app.appData.tasks.splice(taskIndex, 1)[0]; // Remove from local array and store it
             const columnId = deletedTask.columnId;
             const pgmColumns = ['AVI-red', 'AVI-yellow', 'ATTACH-black', 'ATTACH-pink'];
             const taskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
             let parentColumnContent = null;

             if (taskEl) {
                 parentColumnContent = taskEl.parentElement;
                 taskEl.remove(); // Remove from DOM
                 console.log(`[deleteTask] Optimistically removed task ${taskId} from DOM.`);

                 // Update UI for the column it was removed from
                 if (pgmColumns.includes(columnId)) {
                     // Check if PGM column is now empty
                     if (parentColumnContent && parentColumnContent.children.length === 0) {
                         parentColumnContent.appendChild(createEmptyState());
                         console.log(`[deleteTask] Added empty state to PGM column ${columnId}.`);
                     }
                 } else {
                     // Update Dashboard column counter and check empty state
                     app.updateColumnCounter(columnId);
                     if (parentColumnContent && !parentColumnContent.querySelector('.task:not([style*="display: none"])') && !parentColumnContent.querySelector('.empty-state')) {
                         parentColumnContent.appendChild(createEmptyState());
                         console.log(`[deleteTask] Added empty state to Dashboard column ${columnId}.`);
                     }
                 }
             } else {
                 console.warn(`[deleteTask] Task element ${taskId} not found in DOM for optimistic removal.`);
                 // If element wasn't found but data existed, maybe PGM history wasn't rendered yet. Re-render it.
                 if (pgmColumns.includes(columnId)) {
                     console.log("[deleteTask] Task element not in DOM, forcing PGM history render after data removal.");
                     app.renderPgmHistory();
                 }
             }

             // Now, try deleting from the server
             try {
                 console.log(`[deleteTask] Sending DELETE request to server for task ID: ${taskId}`);
                 const response = await fetch(`/api/tasks/${taskId}`, { method: 'DELETE' });

                 if (!response.ok) {
                     // Check if the reason for failure is 404 (Not Found)
                     if (response.status === 404) {
                         console.warn(`[deleteTask] Server returned 404 for task ${taskId}. Assuming already deleted or race condition.`);
                         // Treat 404 as a success locally since the goal is removal
                         // UI is already updated optimistically.
                     } else {
                         // Handle other server errors
                         const errorBody = await response.text();
                         throw new Error(`태스크 삭제 실패 (${response.status}): ${errorBody}`);
                     }
                 } else {
                    console.log(`[deleteTask] Successfully deleted task ${taskId} on server.`);
                    // Success: UI is already updated. Nothing more to do.
                 }

             } catch (error) {
                  // This catch block now only handles non-404 errors thrown above or network errors
                  console.error(`[deleteTask] Server delete failed for task ${taskId}:`, error);
                  alert("태스크 삭제에 실패했습니다. 변경 사항을 되돌립니다. " + error.message);

                  // Rollback: Add the task back to local data
                  app.appData.tasks.splice(taskIndex, 0, deletedTask); // Insert back at original index
                  console.log(`[deleteTask] Rolled back local data for task ${taskId}.`);

                  // Rollback DOM changes
                  // It's simpler to just re-render the affected column/tab
                  if (pgmColumns.includes(columnId)) {
                      console.log(`[deleteTask] Rolling back UI for PGM column ${columnId} by re-rendering.`);
                      app.renderPgmHistory();
                  } else {
                      console.log(`[deleteTask] Rolling back UI for Dashboard column ${columnId} by re-rendering board.`);
                      app.renderBoard(); // Re-render the whole board might be easiest for dashboard rollback
                  }
             }
         };

         const toggleComplete = async (taskId) => {
             const taskIndex = app.appData.tasks.findIndex(task => task.id === taskId); // Use exposed app.appData - OK
             if (taskIndex === -1) return;
             const task = app.appData.tasks[taskIndex]; // Use exposed app.appData - OK
             const newCompletedStatus = !task.completed;
             try {
                 const response = await fetch(`/api/tasks/${taskId}`, { // 서버 API 호출!
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ completed: newCompletedStatus }) // 완료 상태만 전송
                    });
                    if (!response.ok) throw new Error('완료 상태 변경 실패');

                    // 성공 시: 로컬 데이터 업데이트 및 화면 업데이트 (직접 조작)
                    task.completed = newCompletedStatus;
                    const taskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (taskEl) { 
                        // 체크박스는 이미 클릭 이벤트에서 change 리스너에 의해 시각적으로 업데이트되어 있으므로
                        // 여기서는 API 요청이 실패했을 때 원상복귀를 위한 코드만 필요합니다.
                        // 여기서는 별도 처리 없이 로그만 기록
                        console.log(`[toggleComplete] 서버 업데이트 성공: 업무 ${taskId}`);
                    }

                } catch (error) {
                    console.error("완료 상태 변경 오류:", error);
                    alert("완료 상태 변경에 실패했습니다.");
                    
                    // 실패 시 UI 원복
                    const taskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (taskEl) {
                        const checkbox = taskEl.querySelector('.task__checkbox');
                        if (checkbox) {
                            checkbox.checked = task.completed; // 원래 상태로 되돌림
                            // change 이벤트가 다시 발생하지 않으므로 수동으로 스타일 조정
                            taskEl.querySelector('.task__title')?.classList.toggle('task__title--completed', task.completed);
                        }
                    }
                }
                // saveData() 호출 삭제!
            };

         const moveTask = async (taskId, targetColumnId, insertBeforeTaskId = null) => {
             const taskIndex = app.appData.tasks.findIndex(t => t.id === taskId); // Use exposed app.appData - OK
             if (taskIndex === -1) {
                 console.error(`[moveTask] Task ${taskId} not found in local data.`);
                 return;
             }
             const originalColumnId = app.appData.tasks[taskIndex].columnId; // Use exposed app.appData - OK

             // 이동 전 UI 변경 (Optimistic UI)
             const taskEl = document.querySelector(`.task[data-task-id="${taskId}"]`);
             const pgmColumns = ['AVI-red', 'AVI-yellow', 'ATTACH-black', 'ATTACH-pink'];
             const isTargetPgm = pgmColumns.includes(targetColumnId);
             const isOriginalPgm = pgmColumns.includes(originalColumnId);

             let targetColumnContent = isTargetPgm ? getPgmSubColumnContentElement(targetColumnId) : getColumnContentElement(targetColumnId);

             if (taskEl && targetColumnContent) {
                 const originalColumnContent = taskEl.parentElement;
                 const insertBeforeEl = insertBeforeTaskId ? targetColumnContent.querySelector(`.task[data-task-id="${insertBeforeTaskId}"]`) : null;

                 // 새 위치에 삽입
                 targetColumnContent.insertBefore(taskEl, insertBeforeEl);

                 // 빈 상태 메시지 처리 (목표 컬럼)
                 const targetEmptyState = targetColumnContent.querySelector('.empty-state');
                 if (targetEmptyState) targetEmptyState.remove();

                 // 이전 컬럼 처리 (카운터 및 빈 상태)
                 if (originalColumnId !== targetColumnId && originalColumnContent) {
                     if (isOriginalPgm) {
                         if (originalColumnContent.children.length === 0) {
                             originalColumnContent.appendChild(createEmptyState());
                         }
                     } else {
                         app.updateColumnCounter(originalColumnId);
                         if (!originalColumnContent.querySelector('.task:not([style*="display: none"])') && !originalColumnContent.querySelector('.empty-state')) {
                            originalColumnContent.appendChild(createEmptyState());
                         }
                     }
                 }

                 // 목표 컬럼 카운터 업데이트 (Dashboard인 경우)
                 if (!isTargetPgm) {
                     app.updateColumnCounter(targetColumnId);
                 }

                 console.log(`[moveTask] Optimistically moved task ${taskId} from ${originalColumnId} to ${targetColumnId}`);
             } else {
                 console.warn(`[moveTask] Optimistic move failed: Task element or target column not found.`);
             }

             // 서버에 업데이트 요청
             try {
                 const response = await fetch(`/api/tasks/${taskId}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ columnId: targetColumnId }) });
                 if (!response.ok) { const errorBody = await response.text(); throw new Error(`태스크 이동 실패 (${response.status}): ${errorBody}`); }
                 // 서버 성공 시 로컬 데이터 업데이트
                 app.appData.tasks[taskIndex].columnId = targetColumnId; // Update exposed app.appData - OK
                 console.log(`[moveTask] Successfully updated task ${taskId} column to ${targetColumnId} on server.`);
             } catch (error) {
                 console.error("태스크 이동 오류:", error); alert("태스크 이동에 실패했습니다: " + error.message);
                 // 실패 시 전체 UI 롤백
                 console.log("[moveTask] Rolling back UI due to server error.");
                 app.renderBoard(); // Use exposed app.renderBoard - OK
                 app.renderPgmHistory(); // Use exposed app.renderPgmHistory - OK
             }
         };

        // --- AI 액션 실행 함수 (GLOBAL) ---
        const executeProposedAIActions = async (actions) => {
            // ... definition using GLOBAL task functions (addTask, updateTask, deleteTask, moveTask)
            let performedActions = false;
            let actionResults = [];
            const promises = [];
            try {
                actions.forEach(action => {
                    const { type, payload } = action;
                    try {
                        switch (type) {
                            case 'add':
                                if (payload.columnId && payload.title) {
                                    promises.push(addTask({ ...payload }).then(() => `✅ '${payload.title}' 추가 완료.`).catch(e => `❌ '${payload.title}' 추가 오류: ${e.message}`));
                                    performedActions = true;
                                } else { throw new Error("Add: 필요한 정보 부족"); }
                                break;
                            case 'update':
                                if (payload.taskId && payload.updates) {
                                    const task = app.getTaskDataById(payload.taskId);
                                    if (task) {
                                        promises.push(updateTask(payload.taskId, { ...task, ...payload.updates }).then(() => `✅ '${task.title}' 수정 완료.`).catch(e => `❌ '${task.title}' 수정 오류: ${e.message}`));
                                        performedActions = true;
                                    } else { throw new Error(`Update: ID ${payload.taskId} 없음`); }
                                } else { throw new Error("Update: 필요한 정보 부족"); }
                                break;
                            case 'delete':
                                if (payload.taskId) {
                                    const task = app.getTaskDataById(payload.taskId);
                                    if (task) {
                                        const taskTitle = task.title;
                                        promises.push(deleteTask(payload.taskId).then(() => `✅ '${taskTitle}' 삭제 완료.`).catch(e => `❌ '${taskTitle}' 삭제 오류: ${e.message}`));
                                        performedActions = true;
                                    } else { throw new Error(`Delete: ID ${payload.taskId} 없음`); }
                                } else { throw new Error("Delete: 필요한 정보 부족"); }
                                break;
                            case 'move':
                                if (payload.taskId && payload.targetColumnId) {
                                    const task = app.getTaskDataById(payload.taskId);
                                    const column = app.appData.columns.find(c => c.id === payload.targetColumnId);
                                    if (task && column) {
                                        promises.push(moveTask(payload.taskId, payload.targetColumnId).then(() => `✅ '${task.title}' 이동 완료.`).catch(e => `❌ '${task.title}' 이동 오류: ${e.message}`));
                                        performedActions = true;
                                    } else { throw new Error("Move: 업무 또는 컬럼 없음"); }
                                } else { throw new Error("Move: 필요한 정보 부족"); }
                                break;
                            case 'info': actionResults.push(`ℹ️ 정보 조회 완료.`); break;
                            default: actionResults.push(`⚠️ 알 수 없는 액션 '${type}'`);
                        }
                    } catch (actionError) { actionResults.push(`❌ ${type} 준비 오류: ${actionError.message}`); }
                });
                const results = await Promise.all(promises);
                actionResults = actionResults.concat(results);
                const aiResponseElement = document.getElementById('aiResponse');
                if (aiResponseElement) {
                    const successMessages = actionResults.filter(r => r.startsWith('✅') || r.startsWith('ℹ️')).join('<br>');
                    const errorMessages = actionResults.filter(r => r.startsWith('❌') || r.startsWith('⚠️')).join('<br>');
                    aiResponseElement.innerHTML = `<div class='ai-success'>${successMessages || '요청 완료 (변경 없음).'}</div>`;
                    if (errorMessages) { aiResponseElement.innerHTML += `<div class='ai-error' style='margin-top: 10px;'><strong>일부 실패:</strong><br>${errorMessages}</div>`; }
                }
            } catch (globalError) {
                console.error("AI 액션 실행 오류:", globalError);
                const aiResponseElement = document.getElementById('aiResponse');
                if (aiResponseElement) { aiResponseElement.innerHTML = `<div class='ai-error'>⚠️ AI 실행 중 예외: ${utils.escapeHtml(globalError.message)}</div>`; }
            }
        };

        // --- 애플리케이션 시작 ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM 로드됨, 애플리케이션 초기화 시작...");
            app.init().then(() => {
                console.log("애플리케이션이 성공적으로 초기화되었습니다.");
            }).catch(error => {
                console.error("애플리케이션 초기화 중 최종 오류:", error);
                alert("애플리케이션 초기화에 실패했습니다. 페이지를 새로고침하거나 나중에 다시 시도해주세요.");
            });
        });

    </script>
</body>
</html>