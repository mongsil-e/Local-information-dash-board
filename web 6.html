<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Task Management</title>
    <style>
        :root {
            /* Light Theme */
            --primary-color: #1a62e8;
            --secondary-color: #f1f3f4;
            --hover-color: #e8f0fe;
            --border-color: #dadce0;
            --text-color: #202124;
            --text-secondary-color: #5f6368;
            --white-color: #ffffff;
            --success-color: #0f9d58;
            --warning-color: #f4b400;
            --danger-color: #d93025;
            --priority-low-color: #1e88e5;
            --priority-medium-color: var(--warning-color);
            --priority-high-color: var(--danger-color);
            --font-family: 'Roboto', 'Noto Sans KR', sans-serif;
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            --column-bg: #ffffff;
            --body-bg: #f8f9fa;
            --header-bg: var(--primary-color);
            --input-bg: #ffffff;
            --ai-primary: #6e00ff;
            --ai-accent: #00f7ff;
            --placeholder-bg: rgba(26, 98, 232, 0.1);
            --placeholder-border: var(--primary-color);

            /* Dark Theme Variables (will be set via JS) */
            --dark-primary-color: #8ab4f8;
            --dark-secondary-color: #5f6368;
            --dark-hover-color: #3c4043;
            --dark-border-color: #5f6368;
            --dark-text-color: #e8eaed;
            --dark-text-secondary-color: #9aa0a6;
            --dark-white-color: #202124;
            --dark-success-color: #81c995;
            --dark-warning-color: #fdd663;
            --dark-danger-color: #f28b82;
            --dark-priority-low-color: #8ab4f8;
            --dark-priority-medium-color: var(--dark-warning-color);
            --dark-priority-high-color: var(--dark-danger-color);
            --dark-column-bg: #292a2d;
            --dark-body-bg: #202124;
            --dark-header-bg: #1c3aa9;
            --dark-input-bg: #35363a;
            --dark-ai-primary: #8a63ff;
            --dark-ai-accent: #00f7ff;
            --dark-placeholder-bg: rgba(138, 180, 248, 0.1);
            --dark-placeholder-border: var(--dark-primary-color);
        }

        /* Dark Mode */
        .theme-dark {
            --primary-color: var(--dark-primary-color);
            --secondary-color: var(--dark-secondary-color);
            --hover-color: var(--dark-hover-color);
            --border-color: var(--dark-border-color);
            --text-color: var(--dark-text-color);
            --text-secondary-color: var(--dark-text-secondary-color);
            --white-color: var(--dark-white-color);
            --success-color: var(--dark-success-color);
            --warning-color: var(--dark-warning-color);
            --danger-color: var(--dark-danger-color);
            --priority-low-color: var(--dark-priority-low-color);
            --priority-medium-color: var(--dark-priority-medium-color);
            --priority-high-color: var(--dark-priority-high-color);
            --column-bg: var(--dark-column-bg);
            --body-bg: var(--dark-body-bg);
            --header-bg: var(--dark-header-bg);
            --input-bg: var(--dark-input-bg);
            --ai-primary: var(--dark-ai-primary);
            --ai-accent: var(--dark-ai-accent);
            --placeholder-bg: var(--dark-placeholder-bg);
            --placeholder-border: var(--dark-placeholder-border);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: var(--font-family); }
        body { background-color: var(--body-bg); color: var(--text-color); font-size: 14px; line-height: 1.5; transition: background-color 0.3s ease, color 0.3s ease; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; }

        /* Header */
        .header { background-color: var(--header-bg); color: var(--white-color); padding: 16px 24px; display: flex; justify-content: space-between; align-items: center; border-radius: var(--border-radius-md) var(--border-radius-md) 0 0; margin-bottom: 20px; box-shadow: var(--box-shadow); position: relative; }
        .header__logo { font-size: 22px; font-weight: 700; }
        .header__user-area { display: flex; align-items: center; gap: 16px; }
        .header__user-name { font-weight: 500; }
        .header__theme-toggle { background: none; border: none; color: var(--white-color); cursor: pointer; font-size: 20px; padding: 4px; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s ease; }
        .header__theme-toggle:hover { background-color: rgba(255, 255, 255, 0.1); }

        /* Tabs */
        .tabs { display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap; }
        .tabs__tab { padding: 8px 16px; background-color: var(--secondary-color); border: 1px solid transparent; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; font-weight: 500; }
        .tabs__tab--active { background-color: var(--hover-color); color: var(--primary-color); border-color: var(--primary-color); }
        .tabs__tab:hover:not(.tabs__tab--active) { background-color: var(--hover-color); }

        /* Search */
        .search { display: flex; margin-bottom: 20px; position: relative; }
        .search__input { flex-grow: 1; padding: 10px 16px 10px 40px; border: 1px solid var(--border-color); border-radius: 24px; font-size: 14px; transition: all 0.2s ease; background-color: var(--input-bg); color: var(--text-color); }
        .search__input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(26, 98, 232, 0.2); }
        .search__icon { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text-secondary-color); }

        /* AI Controls */
        .ai-controls { display: flex; gap: 10px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .ai-model-selector { padding: 8px 12px; background-color: var(--input-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); cursor: pointer; min-width: 180px; font-size: 13px; }
        .ai-model-selector:disabled { cursor: not-allowed; opacity: 0.6; }
        .ai-btn { padding: 8px 16px; background-color: var(--ai-primary); color: white; border: none; border-radius: var(--border-radius-md); cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 6px; font-size: 13px; }
        .ai-btn:hover { opacity: 0.9; }
        .ai-btn:disabled { background-color: var(--secondary-color); color: var(--text-secondary-color); cursor: not-allowed; opacity: 0.7; }
        .ai-btn--secondary { background-color: var(--secondary-color); color: var(--text-color); }
        .ai-btn--secondary:hover { background-color: var(--hover-color); }

        /* Board */
        .board { display: grid; grid-template-columns: repeat(5, 1fr); gap: 16px; }

        /* Column */
        .column { background-color: var(--column-bg); border-radius: var(--border-radius-md); box-shadow: var(--box-shadow); display: flex; flex-direction: column; overflow: hidden; transition: transform 0.2s ease; }
        .column:hover { transform: translateY(-2px); }
        .column__header { padding: 12px 16px; background-color: var(--secondary-color); font-weight: 600; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); }
        .column__title-area { display: flex; align-items: center; gap: 8px; flex-grow: 1; margin-right: 8px; min-width: 0; /* Prevent overflow */ }
        .column__title { cursor: pointer; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .column__title-input { font-weight: 600; padding: 2px 4px; border: 1px solid var(--primary-color); border-radius: var(--border-radius-sm); width: 100%; background-color: var(--input-bg); color: var(--text-color); font-size: 14px; line-height: 1.5; }
        .column__counter { font-size: 12px; background-color: var(--primary-color); color: white; padding: 2px 6px; border-radius: 10px; margin-left: 4px; flex-shrink: 0; }
        .column__actions { display: flex; align-items: center; gap: 4px; flex-shrink: 0; }

        /* Column Content */
        .column__content { padding: 16px; flex-grow: 1; min-height: 200px; max-height: 65vh; overflow-y: auto; background-color: var(--column-bg); transition: background-color 0.2s ease; position: relative; /* For placeholder positioning */ }
        .column__content--drag-over { background-color: var(--hover-color); } /* Remove outline for placeholder */

        /* Task Placeholder */
        .task--placeholder {
            background-color: var(--placeholder-bg);
            border: 1px dashed var(--placeholder-border);
            border-radius: var(--border-radius-md);
            margin-bottom: 10px;
            height: 50px; /* Adjust height as needed */
            transition: height 0.1s ease;
        }

        .column__quick-add { padding: 0 16px 16px; display: none; }
        .column__quick-add--visible { display: block; }
        .column__quick-add-input { width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); font-size: 14px; background-color: var(--input-bg); color: var(--text-color); }
        .column__quick-add-input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(26, 98, 232, 0.2); }

        /* Action Button */
        .action-btn { background: none; border: none; cursor: pointer; color: var(--text-secondary-color); padding: 4px; border-radius: 50%; width: 28px; height: 28px; display: inline-flex; justify-content: center; align-items: center; transition: all 0.2s ease; }
        .action-btn:hover { background-color: var(--hover-color); color: var(--primary-color); }
        .action-btn--edit { font-size: 14px; }
        .action-btn--add { font-size: 20px; font-weight: bold; }
        .action-btn--menu { font-size: 18px; font-weight: bold; }

        /* Task */
        .task { background-color: var(--column-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 10px 12px; margin-bottom: 10px; cursor: grab; transition: all 0.2s ease, opacity 0s; /* opacity transition off for dragging */ position: relative; display: flex; align-items: flex-start; gap: 8px; border-left: 4px solid transparent; }
        .task--dragging { opacity: 0.5; cursor: grabbing; background-color: var(--hover-color); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); z-index: 10; }
        .task:hover { box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); border-color: var(--border-color); }
        .task--priority-low { border-left-color: var(--priority-low-color); }
        .task--priority-medium { border-left-color: var(--priority-medium-color); }
        .task--priority-high { border-left-color: var(--priority-high-color); }
        .task__checkbox { margin-top: 2px; flex-shrink: 0; cursor: pointer; accent-color: var(--primary-color); }
        .task__content { flex-grow: 1; overflow: hidden; }
        .task__title { font-weight: 500; margin-bottom: 4px; cursor: pointer; word-break: break-word; }
        .task__title--completed { text-decoration: line-through; color: var(--text-secondary-color); font-weight: 400; }
        .task__meta { display: flex; justify-content: space-between; font-size: 12px; color: var(--text-secondary-color); gap: 8px; flex-wrap: wrap; }
        .task__meta-item { white-space: nowrap; display: flex; align-items: center; gap: 4px; }
        .task__due-date--overdue { color: var(--danger-color); font-weight: 500; }
        .task__due-date--today { color: var(--success-color); font-weight: 500; }
        .task__due-date--tomorrow { color: var(--priority-low-color); font-weight: 500; }
        .task__tags { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; }
        .task__tag { font-size: 10px; padding: 2px 6px; border-radius: 10px; background-color: var(--secondary-color); color: var(--text-secondary-color); }
        .task__delete-btn { position: absolute; top: 6px; right: 6px; background: none; border: none; font-size: 18px; line-height: 1; cursor: pointer; color: var(--text-secondary-color); padding: 2px; border-radius: var(--border-radius-sm); transition: all 0.2s ease; }
        .task__delete-btn:hover { color: var(--danger-color); background-color: var(--hover-color); }

        /* Modal */
        .modal { display: none; /* Start hidden */ position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center; z-index: 1000; padding: 20px; opacity: 0; transition: opacity 0.3s ease; /* Only opacity transition */ }
        .modal.visible { display: flex; /* Show when visible class added */ }
        .modal--visible { opacity: 1; } /* Trigger opacity transition */
        .modal__content { background-color: var(--column-bg); padding: 24px; border-radius: var(--border-radius-md); width: 100%; max-width: 500px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); max-height: 90vh; overflow-y: auto; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal--visible .modal__content { transform: scale(1); }
        .modal__header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .modal__title { font-size: 18px; font-weight: 600; }
        .modal__close { background: none; border: none; font-size: 24px; font-weight: bold; line-height: 1; cursor: pointer; color: var(--text-secondary-color); padding: 4px; transition: color 0.2s ease; }
        .modal__close:hover { color: var(--text-color); }

        /* AI Interface */
        .ai-interface { position: fixed; bottom: -100%; /* Start fully hidden */ left: 0; right: 0; background: rgba(10, 10, 30, 0.95); border-top: 1px solid var(--ai-primary); padding: 1.5rem; transition: bottom 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); z-index: 100; max-width: 800px; margin: 0 auto; border-radius: 12px 12px 0 0; box-shadow: 0 -5px 20px rgba(0,0,0,0.3); color: var(--dark-text-color); /* AI interface always dark? */ }
        .ai-interface.active { bottom: 0; }
        .ai-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .ai-title { font-weight: 600; color: var(--ai-accent); }
        .ai-close-btn { background: none; border: none; font-size: 20px; color: var(--text-secondary-color); cursor: pointer; padding: 5px; line-height: 1; }
        .ai-close-btn:hover { color: var(--ai-accent); }
        .ai-input-container { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
        #aiPrompt { flex: 1; background: transparent; border: 1px solid rgba(110, 0, 255, 0.5); border-radius: 20px; padding: 0.8rem 1rem; color: white; outline: none; font-size: 14px; }
        #aiPrompt::placeholder { color: rgba(255,255,255,0.4); }
        #executeAI { background: var(--ai-primary); border: none; border-radius: 20px; padding: 0 1.5rem; color: white; cursor: pointer; transition: all 0.2s ease; font-size: 14px; }
        #executeAI:hover:not(:disabled) { background: #5a00cc; }
        #executeAI:disabled { background: #555; cursor: not-allowed; }
        .ai-suggestions { display: flex; gap: 0.5rem; overflow-x: auto; padding-bottom: 0.5rem; margin-bottom: 1rem; }
        .ai-suggestion { background: rgba(110, 0, 255, 0.2); border-radius: 20px; padding: 0.4rem 0.8rem; font-size: 0.8rem; white-space: nowrap; cursor: pointer; transition: all 0.2s ease; color: #eee; }
        .ai-suggestion:hover { background: rgba(110, 0, 255, 0.4); }
        .ai-response { max-height: 200px; overflow-y: auto; padding: 0.8rem; background: rgba(0,0,0,0.2); border-radius: 8px; margin-top: 1rem; font-size: 13px; line-height: 1.6; color: #eee; }
        .ai-response div { margin-bottom: 0.5rem; }
        .ai-thinking { color: var(--ai-accent); font-style: italic; }
        .ai-error { color: var(--dark-danger-color); font-weight: bold; }
        .ai-success { color: var(--dark-success-color); }
        .ai-response-text { white-space: pre-wrap; } /* Preserve line breaks from AI */

        /* Form */
        .form-group { margin-bottom: 16px; }
        .form-group__label { display: block; margin-bottom: 6px; font-weight: 500; font-size: 13px; }
        .form-group__input, .form-group__select, .form-group__textarea { width: 100%; padding: 10px 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); font-size: 14px; transition: all 0.2s ease; background-color: var(--input-bg); color: var(--text-color); }
        .form-group__input:focus, .form-group__select:focus, .form-group__textarea:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(26, 98, 232, 0.2); }
        .form-group__textarea { min-height: 80px; resize: vertical; }
        .form-group__tags { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
        .form-group__tag { display: inline-flex; align-items: center; font-size: 12px; padding: 4px 8px; background-color: var(--secondary-color); border-radius: var(--border-radius-sm); gap: 4px; color: var(--text-color); }
        .form-group__tag-remove { background: none; border: none; cursor: pointer; color: var(--text-secondary-color); font-size: 12px; padding: 0; line-height: 1; }
        .form-group__tag-remove:hover { color: var(--danger-color); }
        .form-group__tag-input { flex-grow: 1; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); font-size: 14px; background-color: var(--input-bg); color: var(--text-color); }
        .form-group__tag-input:focus { outline: none; border-color: var(--primary-color); }

        /* Form Actions */
        .form-actions { display: flex; justify-content: flex-end; gap: 12px; margin-top: 24px; }

        /* Button */
        .btn { padding: 10px 16px; border-radius: var(--border-radius-sm); cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s ease; border: 1px solid transparent; line-height: 1.4; }
        .btn--primary { background-color: var(--primary-color); color: var(--white-color); border-color: var(--primary-color); }
        .btn--primary:hover { background-color: #185abc; border-color: #185abc; }
        .btn--secondary { background-color: var(--column-bg); color: var(--text-color); border: 1px solid var(--border-color); }
        .btn--secondary:hover { background-color: var(--secondary-color); border-color: var(--border-color); }

        /* Menu */
        .menu { position: absolute; background-color: var(--column-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); z-index: 1001; padding: 4px 0; min-width: 180px; opacity: 0; transform: translateY(-10px) scale(0.95); transform-origin: top left; transition: opacity 0.2s ease, transform 0.2s ease; }
        .menu--visible { opacity: 1; transform: translateY(0) scale(1); }
        .menu__item { padding: 8px 16px; cursor: pointer; transition: background-color 0.2s ease; font-size: 14px; color: var(--text-color); white-space: nowrap; }
        .menu__item:hover { background-color: var(--hover-color); }
        .menu__separator { height: 1px; background-color: var(--border-color); margin: 4px 0; }

        /* Empty State */
        .empty-state { text-align: center; padding: 20px; color: var(--text-secondary-color); font-size: 14px; }

        /* Responsive */
        @media (max-width: 1200px) { .board { grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); } }
        @media (max-width: 768px) {
            .board { grid-template-columns: 1fr; }
            .header { padding: 12px 16px; border-radius: 0; }
            .container { padding: 10px; }
            .modal__content { max-width: 95%; }
            .ai-interface { max-width: 100%; padding: 1rem; border-radius: 8px 8px 0 0; }
            .ai-controls { gap: 8px; }
            .ai-btn, .ai-model-selector { font-size: 12px; padding: 6px 10px; }
        }

        /* Animations */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.3s ease forwards; }
    </style>
</head>
<body>
    <header class="header">
        <div class="header__logo">Ïù∏Ìèº ÌòÑÌô©Ìåê Enhanced</div>
        <div class="header__user-area">
            <div class="header__user-name">Ïù∏Ìèº</div>
            <button class="header__theme-toggle" aria-label="ÌÖåÎßà Ï†ÑÌôò (ÎùºÏù¥Ìä∏/Îã§ÌÅ¨)">üåì</button>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <div class="tabs__tab tabs__tab--active">ÏóÖÎ¨¥ ÎåÄÏãúÎ≥¥Îìú</div>
            <div class="tabs__tab">PGM Update history</div>
            <div class="tabs__tab">ÌÜµÍ≥Ñ</div>
            <div class="tabs__tab">ÏÑ§Ï†ï</div>
        </div>

        <div class="search">
            <span class="search__icon">üîç</span>
            <input type="text" id="searchInput" class="search__input" placeholder="ÏóÖÎ¨¥ Í≤ÄÏÉâ (Ï†úÎ™©, ÏÑ§Î™Ö, Îã¥ÎãπÏûê, ÌÉúÍ∑∏)">
        </div>

        <div class="ai-controls">
            <select id="aiModelSelector" class="ai-model-selector" aria-label="AI Î™®Îç∏ ÏÑ†ÌÉù">
                <option value="">AI Î™®Îç∏ Î°úÎî© Ï§ë...</option>
            </select>
            <button id="toggleAI" class="ai-btn" aria-label="AI ÎèÑÏö∞ÎØ∏ Ïó¥Í∏∞/Îã´Í∏∞">
                <span>ü§ñ</span> AI ÎèÑÏö∞ÎØ∏
            </button>
            <button id="aiOrganize" class="ai-btn ai-btn--secondary" aria-label="AIÎ°ú ÏóÖÎ¨¥ Ï†ïÎ¶¨ Ïã§Ìñâ">
                <span>üß†</span> AIÎ°ú ÏóÖÎ¨¥ Ï†ïÎ¶¨
            </button>
        </div>

        <div class="board" id="board">
            <!-- Columns will be populated dynamically -->
        </div>

        <!-- Add/Edit Task Modal -->
        <div id="taskModal" class="modal" role="dialog" aria-labelledby="modalTitle" aria-hidden="true">
            <div class="modal__content">
                <div class="modal__header">
                    <div id="modalTitle" class="modal__title">ÏÉà ÏóÖÎ¨¥ Ï∂îÍ∞Ä</div>
                    <button class="modal__close" aria-label="Î™®Îã¨ Îã´Í∏∞" onclick="app.closeModal()">√ó</button>
                </div>
                <form id="taskForm">
                    <input type="hidden" id="taskId" name="taskId">
                    <input type="hidden" id="columnId" name="columnId">
                    <div class="form-group">
                        <label for="taskTitle" class="form-group__label">ÏóÖÎ¨¥Î™Ö <span aria-hidden="true">*</span></label>
                        <input type="text" id="taskTitle" name="taskTitle" class="form-group__input" required aria-required="true">
                    </div>
                    <div class="form-group">
                        <label for="taskDescription" class="form-group__label">ÏÑ§Î™Ö</label>
                        <textarea id="taskDescription" name="taskDescription" class="form-group__textarea"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="taskDueDate" class="form-group__label">ÎßàÍ∞êÏùº</label>
                        <input type="date" id="taskDueDate" name="taskDueDate" class="form-group__input">
                    </div>
                    <div class="form-group">
                        <label for="taskAssignees" class="form-group__label">Îã¥ÎãπÏûê</label>
                        <input type="text" id="taskAssignees" name="taskAssignees" class="form-group__input" placeholder="ÏΩ§Îßà(,)Î°ú Íµ¨Î∂Ñ">
                    </div>
                    <div class="form-group">
                        <label for="taskPriority" class="form-group__label">Ï§ëÏöîÎèÑ</label>
                        <select id="taskPriority" name="taskPriority" class="form-group__select">
                            <option value="low">ÎÇÆÏùå</option>
                            <option value="medium" selected>Î≥¥ÌÜµ</option>
                            <option value="high">ÎÜíÏùå</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tagInput" class="form-group__label">ÌÉúÍ∑∏</label>
                        <div id="tagsContainer" class="form-group__tags" aria-live="polite"></div>
                        <input type="text" id="tagInput" class="form-group__tag-input" placeholder="ÌÉúÍ∑∏ ÏûÖÎ†• ÌõÑ ÏóîÌÑ∞">
                    </div>

                    <div class="form-actions">
                        <button type="button" class="btn btn--secondary" onclick="app.closeModal()">Ï∑®ÏÜå</button>
                        <button type="submit" class="btn btn--primary">Ï†ÄÏû•</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Detail Modal -->
        <div id="taskDetailModal" class="modal" role="dialog" aria-labelledby="taskDetailTitle" aria-hidden="true">
            <div class="modal__content">
                <div class="modal__header">
                    <div id="taskDetailTitle" class="modal__title">ÏóÖÎ¨¥ ÏÉÅÏÑ∏</div>
                    <button class="modal__close" aria-label="ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Î™®Îã¨ Îã´Í∏∞" onclick="app.closeDetailModal()">√ó</button>
                </div>
                <div id="taskDetailContent">
                    <!-- Content will be populated by JS -->
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn--secondary" onclick="app.closeDetailModal()">Îã´Í∏∞</button>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ -->
    <div class="ai-interface" id="aiInterface" aria-hidden="true">
        <div class="ai-header">
            <div class="ai-title">AI ÏóÖÎ¨¥ ÎèÑÏö∞ÎØ∏</div>
            <button class="ai-close-btn" id="closeAI" aria-label="AI Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Îã´Í∏∞">‚úï</button>
        </div>
        <div class="ai-input-container">
            <input type="text" id="aiPrompt" placeholder="ÏóÖÎ¨¥ ÏßÄÏãúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: 'ÎßàÍ∞êÏùº ÏûÑÎ∞ï ÏûëÏóÖ Ï†ïÎ†¨')">
            <button id="executeAI" aria-label="AI Î™ÖÎ†πÏñ¥ Ïã§Ìñâ">Ïã§Ìñâ</button>
        </div>
        <div class="ai-suggestions">
            <div class="ai-suggestion" data-prompt="Ïò§Îäò ÎßàÍ∞êÏù∏ ÏûëÏóÖÏùÄ?">Ïò§Îäò ÎßàÍ∞êÏù∏Ïù∏ ÏûëÏóÖ</div>
            <div class="ai-suggestion" data-prompt="ÎßàÍ∞êÎêòÏßÄ ÏïäÏùÄ ÏûëÏóÖÎì§Îßå Ïö∞ÏÑ†ÏàúÏúÑÎ°ú Ï†ïÎ†¨Ìï¥Ï§ò">Ïö∞ÏÑ† ÏàúÏúÑÎ°ú Ï†ïÎ†¨ Ìï¥Ï§ò</div>
            <div class="ai-suggestion" data-prompt="ÏôÑÎ£åÎêú ÏûëÏóÖ Ïà®Í∏∞Í∏∞ ÎòêÎäî ÏïÑÏπ¥Ïù¥Î∏å">ÏôÑÎ£å ÏûëÏóÖ Ï†ïÎ¶¨</div>
            <div class="ai-suggestion" data-prompt="'Îß§ÏùºÌï†Ïùº' Ïóê 'Ï±ÖÏÉÅ Ï†ïÎ¶¨' Ï∂îÍ∞ÄÌï¥Ï§ò">ÏÉà ÏóÖÎ¨¥ Ï∂îÍ∞Ä ÏòàÏãú</div>
            <div class="ai-suggestion" data-prompt="ÎßàÍ∞êÏùº ÏßÄÎÇú ÏóÖÎ¨¥ Ï†ïÎ¶¨Ìï¥Ï§ò">ÎßàÍ∞êÏùº ÏßÄÎÇú ÏóÖÎ¨¥</div>
            <!--<div class="ai-suggestion" data-prompt="Ïò§Îäò ÎßàÍ∞êÏù∏ ÏóÖÎ¨¥Ïóê 'Í∏¥Í∏â' ÌÉúÍ∑∏ Ï∂îÍ∞Ä">Ïò§Îäò ÎßàÍ∞ê ÌÉúÍ∑∏ Ï∂îÍ∞Ä</div>-->
        </div>
        <div class="ai-response" id="aiResponse" aria-live="assertive"></div>
    </div>

    <script>
        // --- Constants ---
        const LOCAL_STORAGE_DATA_KEY = 'taskAppData_v2'; // Versioning for potential structure changes
        const LOCAL_STORAGE_SETTINGS_KEY = 'taskAppSettings_v2';
        const JAN_API_BASE_URL = "http://127.0.0.1:1337/v1";
        const JAN_API_CHAT_ENDPOINT = "/chat/completions";
        const JAN_API_MODELS_ENDPOINT = "/models";
        const DEBOUNCE_DELAY = 300; // ms for search input debounce

        // --- Utility Functions ---
        const utils = {
            generateId: () => `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(this, args); // Use apply to maintain context
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },
            formatDueDateForDisplay: (dueDateString) => {
                if (!dueDateString) return 'ÎÇ†Ïßú ÏóÜÏùå';
                try {
                    const date = new Date(dueDateString);
                    date.setHours(0, 0, 0, 0);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const tomorrow = new Date(today);
                    tomorrow.setDate(today.getDate() + 1);

                    const timeDiff = date.getTime() - today.getTime();
                    const dayDiff = Math.ceil(timeDiff / (1000 * 3600 * 24)); // Use Math.ceil

                    if (dayDiff < 0) return 'Í∏∞ÌïúÏßÄÎÇ®';
                    if (dayDiff === 0) return 'Ïò§Îäò';
                    if (dayDiff === 1) return 'ÎÇ¥Ïùº';

                    // More robust date formatting
                    return date.toLocaleDateString('ko-KR', { year: 'numeric', month: 'short', day: 'numeric' });
                } catch (e) {
                    console.error("Error formatting date:", dueDateString, e);
                    return 'ÎÇ†Ïßú ÌòïÏãù Ïò§Î•ò';
                }
            },
            getDueDateClass: (dueDateString) => {
                if (!dueDateString) return '';
                try {
                    const date = new Date(dueDateString);
                    date.setHours(0, 0, 0, 0);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);

                    const timeDiff = date.getTime() - today.getTime();
                    const dayDiff = Math.ceil(timeDiff / (1000 * 3600 * 24)); // Use Math.ceil

                    if (dayDiff < 0) return 'task__due-date--overdue';
                    if (dayDiff === 0) return 'task__due-date--today';
                    if (dayDiff === 1) return 'task__due-date--tomorrow';
                    return '';
                } catch (e) {
                    return '';
                }
            },
            // Simple alert for feedback (replace with a Toast library later if needed)
            showFeedback: (message, type = 'info') => {
                // console[type](message); // Log to console as well
                alert(`[${type.toUpperCase()}] ${message}`);
            },
            escapeHtml: (unsafe) => {
                 return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }
        };

        const app = (function(utils) {
            // --- State ---
            let appData = {
                tasks: [],
                columns: [
                    { id: 'daily', title: 'Îß§Ïùº Ìï†Ïùº', order: 0 },
                    { id: 'input', title: 'Ïù∏Ìèº ÏÇ¨Ìï≠', order: 1 },
                    { id: 'instruction1', title: 'ÏßÄÏãú ÏÇ¨Ìï≠ 1', order: 2 },
                    { id: 'instruction2', title: 'ÏßÄÏãú ÏÇ¨Ìï≠ 2', order: 3 },
                    { id: 'pgm', title: 'PGM Î≥ÄÍ≤Ω ÎÇ¥Ïó≠', order: 4 }
                ],
                settings: {
                    darkMode: false,
                    showQuickAdd: true
                },
                janAI: {
                    connected: false,
                    model: null,
                    availableModels: []
                }
            };

            let draggedTask = null;
            let dragPlaceholder = null;
            let currentMenu = null;
            let currentTags = [];

            // --- DOM Elements ---
            const board = document.getElementById('board');
            const taskModal = document.getElementById('taskModal');
            const taskForm = document.getElementById('taskForm');
            const modalTitle = document.getElementById('modalTitle');
            const searchInput = document.getElementById('searchInput');
            const detailModal = document.getElementById('taskDetailModal');
            const detailContent = document.getElementById('taskDetailContent');
            const tagInput = document.getElementById('tagInput');
            const tagsContainer = document.getElementById('tagsContainer');
            const themeToggle = document.querySelector('.header__theme-toggle');
            const aiModelSelector = document.getElementById('aiModelSelector');
            const toggleAI = document.getElementById('toggleAI');
            const aiOrganize = document.getElementById('aiOrganize');
            const aiInterface = document.getElementById('aiInterface');
            const aiPrompt = document.getElementById('aiPrompt');
            const executeAI = document.getElementById('executeAI');
            const closeAI = document.getElementById('closeAI');
            const aiResponse = document.getElementById('aiResponse');
            const aiSuggestions = document.querySelector('.ai-suggestions');

            // --- Jan API Class ---
            class JanAI {
                constructor() {
                    this.baseUrl = JAN_API_BASE_URL;
                    this.chatEndpoint = JAN_API_CHAT_ENDPOINT;
                    this.modelsEndpoint = JAN_API_MODELS_ENDPOINT;
                }

// JanAI ÌÅ¥ÎûòÏä§ ÎÇ¥ checkConnection Ìï®Ïàò ÏàòÏ†ï

async checkConnection() {
    // ... (Í∏∞Ï°¥ ÏΩîÎìú: fetch ÏöîÏ≤≠ Ï†ÑÍπåÏßÄ)
    try {
        const response = await fetch(`${this.baseUrl}${this.modelsEndpoint}`); // ÌïÑÏöîÌïòÎã§Î©¥ Ïó¨Í∏∞Ïóê ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞Ä (Í∞ÄÎä•ÏÑ± 3 Ï∞∏Í≥†)
        if (!response.ok) throw new Error(`API Ïó∞Í≤∞ Ïã§Ìå® (${response.status})`);

        const data = await response.json();
        const allModels = data.data || [];

        // --- Ïó¨Í∏∞Í∞Ä Ï§ëÏöî: Î°úÏª¨/Îã§Ïö¥Î°úÎìúÎêú Î™®Îç∏Îßå ÌïÑÌÑ∞ÎßÅ ---
        // ÏòàÏãú: ÎßåÏïΩ Î™®Îç∏ Í∞ùÏ≤¥Ïóê 'status' ÏÜçÏÑ±Ïù¥ ÏûàÍ≥†, Ï§ÄÎπÑÎêú ÏÉÅÌÉúÍ∞Ä 'downloaded' Ïù∏ Î™®Îç∏Îßå Î¶¨Ïä§Ìä∏ÏóÖ Ìï¥ÏÑú ÎùÑÏõÄ
        // ÌôïÏù∏ Î∞©Î≤ï Í∞úÎ∞úÏûê ÎèÑÍµ¨>ÎÑ§Ìä∏ÏõåÌÅ¨>response> Î°úÏª¨ Î™®Îç∏Í≥º ÏïÑÎãåÎ™®Îç∏ ÎπÑÍµêÏãú downloadedÏôÄ downloadableÏùò Ï∞®Ïù¥Ï†êÏù¥ ÏûàÏóàÏùåÏùå
        const localModels = allModels.filter(model => model.status === 'downloaded' /* ÎòêÎäî model.downloaded === true Îì± */);
        // ÎòêÎäî ID ÌòïÏãùÏùÑ Î≥¥Í≥† ÌïÑÌÑ∞ÎßÅÌï¥Ïïº Ìï† ÏàòÎèÑ ÏûàÏäµÎãàÎã§. (Ïòà: model.id.startsWith('local-') )

        // appData ÏóÖÎç∞Ïù¥Ìä∏ Î∞è Î™®Îç∏ ÏÑ†ÌÉùÍ∏∞ Ï±ÑÏö∞Í∏∞Îäî ÌïÑÌÑ∞ÎßÅÎêú Î™©Î°ù(localModels)ÏúºÎ°ú ÏàòÌñâ
        appData.janAI.connected = true;
        appData.janAI.availableModels = localModels; // ÌïÑÌÑ∞ÎßÅÎêú Î™©Î°ù Ï†ÄÏû•

        if (localModels.length > 0) {
            appData.janAI.model = localModels[0].id; // Í∏∞Î≥∏ ÏÑ†ÌÉùÎèÑ ÌïÑÌÑ∞ÎßÅÎêú Î™©Î°ùÏóêÏÑú
            this.updateModelSelector(localModels);   // ÏÑ†ÌÉùÍ∏∞ ÏóÖÎç∞Ïù¥Ìä∏ÎèÑ ÌïÑÌÑ∞ÎßÅÎêú Î™©Î°ùÏúºÎ°ú
            aiModelSelector.disabled = false;
            toggleAI.disabled = false;
            aiOrganize.disabled = false;
            console.info("Jan.ai Ïó∞Í≤∞ ÏÑ±Í≥µ (Î°úÏª¨ Î™®Îç∏ ÌïÑÌÑ∞ÎßÅÎê®):", localModels.map(m => m.id).join(', '));
        } else {
            // ÌïÑÌÑ∞ÎßÅ ÌõÑ Î™®Îç∏Ïù¥ ÌïòÎÇòÎèÑ ÏóÜÎã§Î©¥
            throw new Error("ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î°úÏª¨ AI Î™®Îç∏Ïù¥ ÏóÜÏäµÎãàÎã§.");
        }
        return { connected: true, models: localModels }; // Î∞òÌôòÍ∞íÎèÑ ÌïÑÌÑ∞ÎßÅÎêú Î™©Î°ùÏúºÎ°ú

    } catch (error) {
        // ... (Í∏∞Ï°¥ ÏóêÎü¨ Ï≤òÎ¶¨ ÏΩîÎìú)
        console.error("Jan.ai Ïó∞Í≤∞ ÎòêÎäî Î™®Îç∏ ÌïÑÌÑ∞ÎßÅ Ïò§Î•ò:", error);
        // ...
    }
}

                updateModelSelector(models) {
                    aiModelSelector.innerHTML = ''; // Clear existing options
                    if (models.length === 0) {
                        aiModelSelector.innerHTML = '<option value="">ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îç∏ ÏóÜÏùå</option>';
                        aiModelSelector.disabled = true;
                        return;
                    }

                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.id.length > 30 ? model.id.substring(0, 27) + '...' : model.id; // Shorten long names
                        option.title = model.id; // Full name on hover
                        aiModelSelector.appendChild(option);
                    });

                    aiModelSelector.value = appData.janAI.model || models[0].id;
                    aiModelSelector.disabled = false;
                }

                async sendPrompt(prompt, systemMessage = null) {
                    if (!appData.janAI.connected || !appData.janAI.model) {
                        throw new Error("JanÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò Î™®Îç∏Ïù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.");
                    }

                    setAIProcessing(true); // Disable button, show loading

                    const messages = [];
                    if (systemMessage) {
                        messages.push({ role: "system", content: systemMessage });
                    }
                    messages.push({ role: "user", content: prompt });

                    try {
                        const response = await fetch(`${this.baseUrl}${this.chatEndpoint}`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                model: appData.janAI.model,
                                messages: messages,
                                temperature: 0.7, // Consider making configurable
                                max_tokens: 1500 // Adjust as needed
                            })
                        });

                        if (!response.ok) {
                            const errorBody = await response.text();
                            throw new Error(`API ÏöîÏ≤≠ Ïã§Ìå® (${response.status}): ${errorBody}`);
                        }

                        return await response.json();
                    } finally {
                        setAIProcessing(false); // Re-enable button
                    }
                }
            }
            const janAI = new JanAI();

            // --- Data Management ---
            const loadData = () => {
                // Load app data
                try {
                    const storedData = localStorage.getItem(LOCAL_STORAGE_DATA_KEY);
                    if (storedData) {
                        const parsedData = JSON.parse(storedData);
                        appData.tasks = Array.isArray(parsedData.tasks) ? parsedData.tasks : [];
                        appData.columns = Array.isArray(parsedData.columns) ? parsedData.columns : appData.columns; // Keep default if invalid
                        console.info("Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å.");
                    }
                } catch (e) {
                    console.error("Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞ ÌååÏã± Ïò§Î•ò:", e);
                    utils.showFeedback("Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏãúÏûëÌï©ÎãàÎã§.", 'error');
                    // Optionally clear corrupted data: localStorage.removeItem(LOCAL_STORAGE_DATA_KEY);
                }

                // Load settings
                try {
                    const storedSettings = localStorage.getItem(LOCAL_STORAGE_SETTINGS_KEY);
                    if (storedSettings) {
                        const parsedSettings = JSON.parse(storedSettings);
                        // Merge carefully, keeping defaults for missing keys
                        appData.settings = { ...appData.settings, ...parsedSettings };
                        console.info("ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å.");
                    }
                } catch (e) {
                    console.error("Ï†ÄÏû•Îêú ÏÑ§Ï†ï ÌååÏã± Ïò§Î•ò:", e);
                     // Settings are less critical, proceed with defaults
                } finally {
                    // Apply settings regardless of loading success
                    applyTheme();
                    applyQuickAddVisibility(); // If needed later
                }
            };

            const saveData = () => {
                try {
                    localStorage.setItem(LOCAL_STORAGE_DATA_KEY, JSON.stringify({
                        tasks: appData.tasks,
                        columns: appData.columns
                    }));
                } catch (e) {
                    console.error("Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ïò§Î•ò:", e);
                    utils.showFeedback("Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.", 'error');
                }
            };

            const saveSettings = () => {
                try {
                    localStorage.setItem(LOCAL_STORAGE_SETTINGS_KEY, JSON.stringify(appData.settings));
                } catch (e) {
                    console.error("ÏÑ§Ï†ï Ï†ÄÏû• Ïò§Î•ò:", e);
                    // Less critical, maybe just log
                }
            };

            // --- Theme & Settings Application ---
            const applyTheme = () => {
                document.body.classList.toggle('theme-dark', appData.settings.darkMode);
                themeToggle.textContent = appData.settings.darkMode ? '‚òÄÔ∏è' : 'üåô';
                themeToggle.setAttribute('aria-label', appData.settings.darkMode ? 'ÎùºÏù¥Ìä∏ Î™®Îìú Ï†ÑÌôò' : 'Îã§ÌÅ¨ Î™®Îìú Ï†ÑÌôò');
            }

            const toggleDarkMode = () => {
                appData.settings.darkMode = !appData.settings.darkMode;
                applyTheme();
                saveSettings();
            };

            const applyQuickAddVisibility = () => {
                // TODO: If quick add toggle is implemented, update visibility here
                const quickAddElements = board.querySelectorAll('.column__quick-add');
                 quickAddElements.forEach(el => {
                     el.style.display = appData.settings.showQuickAdd ? 'block' : 'none';
                 });
            };

            // --- Rendering ---
            const getTaskDataById = (id) => appData.tasks.find(task => task.id === id);
            const getColumnElementById = (id) => board.querySelector(`.column[data-column-id="${id}"]`);
            const getColumnContentElement = (id) => board.querySelector(`.column__content[data-column-id="${id}"]`);
            const getColumnTitleElement = (columnId) => getColumnElementById(columnId)?.querySelector('.column__title');

            const createTaskElement = (task) => {
                const taskEl = document.createElement('div');
                taskEl.className = `task task--priority-${task.priority || 'medium'}`;
                taskEl.setAttribute('draggable', true);
                taskEl.dataset.taskId = task.id;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'task__checkbox';
                checkbox.checked = task.completed;
                checkbox.dataset.action = 'toggleComplete';
                checkbox.setAttribute('aria-label', `ÏóÖÎ¨¥ ${task.completed ? 'ÎØ∏ÏôÑÎ£åÎ°ú' : 'ÏôÑÎ£åÎ°ú'} ÌëúÏãú: ${task.title}`);
                taskEl.appendChild(checkbox);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'task__content';

                const titleEl = document.createElement('div');
                titleEl.className = `task__title ${task.completed ? 'task__title--completed' : ''}`;
                titleEl.textContent = task.title;
                titleEl.dataset.action = 'openDetail'; // Changed from openEdit to openDetail by default
                contentDiv.appendChild(titleEl);

                const metaEl = document.createElement('div');
                metaEl.className = 'task__meta';

                const dueDateEl = document.createElement('div');
                dueDateEl.className = `task__meta-item ${utils.getDueDateClass(task.dueDate)}`;
                dueDateEl.innerHTML = `<span>üóìÔ∏è</span> ${utils.formatDueDateForDisplay(task.dueDate)}`;
                metaEl.appendChild(dueDateEl);

                if (task.assignees) {
                    const assigneesEl = document.createElement('div');
                    assigneesEl.className = 'task__meta-item';
                    assigneesEl.innerHTML = `<span>üë§</span> ${utils.escapeHtml(task.assignees)}`;
                    metaEl.appendChild(assigneesEl);
                }
                contentDiv.appendChild(metaEl);

                if (task.tags && task.tags.length > 0) {
                    const tagsEl = document.createElement('div');
                    tagsEl.className = 'task__tags';
                    task.tags.forEach(tag => {
                        const tagEl = document.createElement('span');
                        tagEl.className = 'task__tag';
                        tagEl.textContent = utils.escapeHtml(tag);
                        tagsEl.appendChild(tagEl);
                    });
                    contentDiv.appendChild(tagsEl);
                }
                taskEl.appendChild(contentDiv);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'task__delete-btn';
                deleteBtn.innerHTML = '√ó';
                deleteBtn.dataset.action = 'deleteTask';
                deleteBtn.setAttribute('aria-label', `ÏóÖÎ¨¥ ÏÇ≠Ï†ú: ${task.title}`);
                taskEl.appendChild(deleteBtn);

                taskEl.addEventListener('dragstart', handleDragStart);
                taskEl.addEventListener('dragend', handleDragEnd);
                taskEl.addEventListener('dblclick', () => openTaskModal('edit', null, task.id)); // Double click to edit

                return taskEl;
            };

            const renderBoard = () => {
                board.innerHTML = ''; // Clear board
                const sortedColumns = [...appData.columns].sort((a, b) => a.order - b.order);

                sortedColumns.forEach(column => {
                    const columnEl = document.createElement('div');
                    columnEl.className = 'column';
                    columnEl.dataset.columnId = column.id;

                    // --- Header ---
                    const headerEl = document.createElement('div');
                    headerEl.className = 'column__header';

                    const titleAreaEl = document.createElement('div');
                    titleAreaEl.className = 'column__title-area';

                    const titleEl = document.createElement('span');
                    titleEl.className = 'column__title';
                    titleEl.textContent = column.title;
                    titleEl.title = "ÎçîÎ∏îÌÅ¥Î¶≠ÌïòÏó¨ Ïù¥Î¶Ñ ÏàòÏ†ï"; // Tooltip
                    titleEl.addEventListener('dblclick', () => startEditingColumnTitle(titleAreaEl)); // Double click to edit title

                    const counterEl = document.createElement('span');
                    counterEl.className = 'column__counter';
                    counterEl.setAttribute('aria-live', 'polite'); // Announce changes

                    titleAreaEl.appendChild(titleEl);
                    titleAreaEl.appendChild(counterEl);

                    // No separate edit button needed if using double-click
                    // const editBtn = document.createElement('button'); ...

                    headerEl.appendChild(titleAreaEl);

                    const actionsEl = document.createElement('div');
                    actionsEl.className = 'column__actions';

                    const addBtn = document.createElement('button');
                    addBtn.className = 'action-btn action-btn--add';
                    addBtn.dataset.action = 'addTask';
                    addBtn.dataset.columnTarget = column.id;
                    addBtn.setAttribute('aria-label', `${column.title} Ïª¨ÎüºÏóê ÏÉà ÏóÖÎ¨¥ Ï∂îÍ∞Ä`);
                    addBtn.textContent = '+';
                    actionsEl.appendChild(addBtn);

                    const menuBtn = document.createElement('button');
                    menuBtn.className = 'action-btn action-btn--menu';
                    menuBtn.dataset.action = 'openColumnMenu';
                    menuBtn.dataset.columnTarget = column.id;
                    menuBtn.setAttribute('aria-label', `${column.title} Ïª¨Îüº Î©îÎâ¥ Ïó¥Í∏∞`);
                    menuBtn.textContent = '‚ãÆ';
                    actionsEl.appendChild(menuBtn);

                    headerEl.appendChild(actionsEl);
                    columnEl.appendChild(headerEl);

                    // --- Content ---
                    const contentEl = document.createElement('div');
                    contentEl.className = 'column__content';
                    contentEl.dataset.columnId = column.id;
                    contentEl.addEventListener('dragover', handleDragOver);
                    contentEl.addEventListener('dragleave', handleDragLeave);
                    contentEl.addEventListener('drop', handleDrop);

                    const columnTasks = appData.tasks
                        .filter(task => task.columnId === column.id)
                        .sort((a, b) => (new Date(a.dueDate || '9999-12-31')) - (new Date(b.dueDate || '9999-12-31'))); // Sort by due date

                    if (columnTasks.length === 0) {
                        contentEl.appendChild(createEmptyState());
                    } else {
                        columnTasks.forEach(task => contentEl.appendChild(createTaskElement(task)));
                    }
                    columnEl.appendChild(contentEl);

                    // Update counter after tasks are added
                    counterEl.textContent = columnTasks.length;

                    // --- Quick Add ---
                    if (appData.settings.showQuickAdd) {
                        const quickAddEl = document.createElement('div');
                        quickAddEl.className = 'column__quick-add';
                        quickAddEl.style.display = appData.settings.showQuickAdd ? 'block' : 'none'; // Direct style for now

                        const inputEl = document.createElement('input');
                        inputEl.className = 'column__quick-add-input';
                        inputEl.placeholder = 'Îπ†Î•∏ Ï∂îÍ∞Ä (Enter)';
                        inputEl.dataset.columnId = column.id;
                        inputEl.setAttribute('aria-label', `${column.title}Ïóê Îπ†Î•∏ ÏóÖÎ¨¥ Ï∂îÍ∞Ä`);

                        inputEl.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' && e.target.value.trim()) {
                                const newTitle = e.target.value.trim();
                                addTask({
                                    columnId: column.id,
                                    title: newTitle,
                                });
                                e.target.value = '';
                                utils.showFeedback(`'${newTitle}' ÏóÖÎ¨¥ Ï∂îÍ∞ÄÎê®`);
                            }
                        });
                        quickAddEl.appendChild(inputEl);
                        columnEl.appendChild(quickAddEl);
                    }

                    board.appendChild(columnEl);
                });

                // Re-apply search filter if needed
                const currentSearchTerm = searchInput.value.trim();
                if (currentSearchTerm) {
                    filterTasks(currentSearchTerm);
                }
            };

            const createEmptyState = () => {
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-state';
                emptyState.textContent = 'ÏóÖÎ¨¥Í∞Ä ÏóÜÏäµÎãàÎã§';
                return emptyState;
            };

            const updateColumnCounter = (columnId) => {
                const column = getColumnElementById(columnId);
                if (column) {
                    const counter = column.querySelector('.column__counter');
                    const content = column.querySelector('.column__content');
                    const taskCount = content ? content.querySelectorAll('.task').length : 0;
                    if (counter) counter.textContent = taskCount;

                    // Toggle empty state
                    const emptyState = content.querySelector('.empty-state');
                    if (taskCount === 0 && !emptyState) {
                        content.appendChild(createEmptyState());
                    } else if (taskCount > 0 && emptyState) {
                        emptyState.remove();
                    }
                }
            };

            // --- Task Management ---
            const addTask = (taskData) => {
                const newTask = {
                    id: utils.generateId(),
                    completed: false,
                    priority: 'medium',
                    tags: [...currentTags], // Add tags from modal state if any
                    ...taskData // Overwrite with provided data
                };
                currentTags = []; // Reset modal tags

                appData.tasks.push(newTask);
                saveData();

                const columnContent = getColumnContentElement(newTask.columnId);
                if (columnContent) {
                    columnContent.appendChild(createTaskElement(newTask));
                    updateColumnCounter(newTask.columnId);
                }
                // utils.showFeedback(`'${newTask.title}' ÏóÖÎ¨¥ Ï∂îÍ∞ÄÎê®.`); // Feedback handled in quick add or form submit
            };

            const updateTask = (taskId, updatedData) => {
                const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
                if (taskIndex > -1) {
                    // Ensure tags are handled correctly (use currentTags from modal if editing)
                    updatedData.tags = [...currentTags];
                    currentTags = [];

                    const originalColumnId = appData.tasks[taskIndex].columnId;
                    appData.tasks[taskIndex] = { ...appData.tasks[taskIndex], ...updatedData };
                    saveData();

                    // Re-render the specific task
                    const taskEl = board.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (taskEl) {
                        const newTaskEl = createTaskElement(appData.tasks[taskIndex]);
                        taskEl.replaceWith(newTaskEl);
                    }

                    // Update counters if column changed (though less likely via edit modal)
                    if (originalColumnId !== updatedData.columnId) {
                        updateColumnCounter(originalColumnId);
                        updateColumnCounter(updatedData.columnId);
                    } else {
                        updateColumnCounter(originalColumnId); // Update original column counter
                    }
                    utils.showFeedback(`'${updatedData.title}' ÏóÖÎ¨¥ ÏàòÏ†ïÎê®.`);
                } else {
                     console.error("ÏàòÏ†ïÌï† ÏóÖÎ¨¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:", taskId);
                     utils.showFeedback("ÏóÖÎ¨¥ ÏàòÏ†ï Ï§ë Ïò§Î•ò Î∞úÏÉù", 'error');
                }
            };

            const deleteTask = (taskId) => {
                const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
                if (taskIndex > -1) {
                    const deletedTask = appData.tasks[taskIndex];
                    const columnId = deletedTask.columnId;
                    appData.tasks.splice(taskIndex, 1);
                    saveData();

                    const taskEl = board.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (taskEl) {
                        taskEl.remove();
                        updateColumnCounter(columnId);
                        utils.showFeedback(`'${deletedTask.title}' ÏóÖÎ¨¥ ÏÇ≠Ï†úÎê®.`);
                    }
                }
            };

            const toggleComplete = (taskId) => {
                const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
                if (taskIndex > -1) {
                    const task = appData.tasks[taskIndex];
                    task.completed = !task.completed;
                    saveData();

                    const taskEl = board.querySelector(`.task[data-task-id="${taskId}"]`);
                    if (taskEl) {
                        const titleEl = taskEl.querySelector('.task__title');
                        const checkbox = taskEl.querySelector('.task__checkbox');
                        checkbox.checked = task.completed;
                        checkbox.setAttribute('aria-label', `ÏóÖÎ¨¥ ${task.completed ? 'ÎØ∏ÏôÑÎ£åÎ°ú' : 'ÏôÑÎ£åÎ°ú'} ÌëúÏãú: ${task.title}`);
                        titleEl.classList.toggle('task__title--completed', task.completed);
                        // No full re-render needed
                    }
                }
            };

            const moveTask = (taskId, targetColumnId, insertBeforeTaskId = null) => {
                const taskIndex = appData.tasks.findIndex(t => t.id === taskId);
                if (taskIndex === -1) return;

                const movedTask = appData.tasks.splice(taskIndex, 1)[0];
                const originalColumnId = movedTask.columnId;
                movedTask.columnId = targetColumnId;

                // Find the correct index to insert in the main tasks array based on the visual order
                const tasksInTargetColumn = appData.tasks.filter(t => t.columnId === targetColumnId);
                let targetIndex = -1;

                if (insertBeforeTaskId) {
                    const insertBeforeIndex = tasksInTargetColumn.findIndex(t => t.id === insertBeforeTaskId);
                    if (insertBeforeIndex !== -1) {
                         // Find the index in the *main* tasks array corresponding to the visual insertion point
                        const actualInsertBeforeTask = tasksInTargetColumn[insertBeforeIndex];
                        targetIndex = appData.tasks.findIndex(t => t.id === actualInsertBeforeTask.id);
                    }
                }

                if (targetIndex !== -1) {
                    appData.tasks.splice(targetIndex, 0, movedTask);
                } else {
                    // If no specific position or insertBefore task not found, append to end of all tasks (will be sorted on render)
                    // Or, better: find the last task of the target column and insert after it
                    let lastTaskOfColumnIndex = -1;
                    for (let i = appData.tasks.length - 1; i >= 0; i--) {
                        if (appData.tasks[i].columnId === targetColumnId) {
                            lastTaskOfColumnIndex = i;
                            break;
                        }
                    }
                    if (lastTaskOfColumnIndex !== -1) {
                         appData.tasks.splice(lastTaskOfColumnIndex + 1, 0, movedTask);
                    } else {
                         appData.tasks.push(movedTask); // If column was empty
                    }
                }


                saveData();
                renderBoard(); // Re-render the entire board after move for simplicity, sorting needs full context
                // More optimized: move the DOM element directly and update counters
                // const taskEl = board.querySelector(`.task[data-task-id="${taskId}"]`);
                // const targetContent = getColumnContentElement(targetColumnId);
                // const insertBeforeEl = insertBeforeTaskId ? board.querySelector(`.task[data-task-id="${insertBeforeTaskId}"]`) : null;
                // if (taskEl && targetContent) {
                //     targetContent.insertBefore(taskEl, insertBeforeEl);
                //     updateColumnCounter(originalColumnId);
                //     updateColumnCounter(targetColumnId);
                // }
            };

            // --- Column Management ---
            const startEditingColumnTitle = (titleContainer) => {
                const titleSpan = titleContainer.querySelector('.column__title');
                // Prevent editing if already editing
                if (titleContainer.querySelector('.column__title-input')) return;

                const currentTitle = titleSpan.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentTitle;
                input.className = 'column__title-input';
                input.setAttribute('aria-label', 'Ïª¨Îüº Ïù¥Î¶Ñ ÏàòÏ†ï');

                titleSpan.style.display = 'none'; // Hide span
                titleContainer.insertBefore(input, titleSpan.nextSibling); // Insert input after span
                input.focus();
                input.select();

                const finishEditing = (save = true) => {
                    const columnId = titleContainer.closest('.column').dataset.columnId;
                    const newTitle = save ? input.value.trim() : currentTitle;

                    input.remove(); // Remove input first
                    titleSpan.style.display = ''; // Show span again

                    if (save && newTitle && newTitle !== currentTitle) {
                        updateColumnTitle(columnId, newTitle);
                         // Update aria-labels for buttons
                        const columnElement = getColumnElementById(columnId);
                        columnElement.querySelector('.action-btn--add')?.setAttribute('aria-label', `${newTitle} Ïª¨ÎüºÏóê ÏÉà ÏóÖÎ¨¥ Ï∂îÍ∞Ä`);
                        columnElement.querySelector('.action-btn--menu')?.setAttribute('aria-label', `${newTitle} Ïª¨Îüº Î©îÎâ¥ Ïó¥Í∏∞`);
                    } else {
                         titleSpan.textContent = currentTitle; // Restore original if not saved or empty
                    }
                    // Remove listeners attached to the input
                };

                const handleBlur = () => finishEditing();
                const handleInputKeydown = (e) => {
                    if (e.key === 'Enter') finishEditing();
                    else if (e.key === 'Escape') finishEditing(false);
                };

                input.addEventListener('blur', handleBlur, { once: true }); // Use once to auto-remove
                input.addEventListener('keydown', handleInputKeydown);
            };

            const updateColumnTitle = (columnId, newTitle) => {
                const column = appData.columns.find(c => c.id === columnId);
                if (column && newTitle) {
                    column.title = newTitle;
                    saveData();
                    const titleEl = getColumnTitleElement(columnId);
                    if (titleEl) titleEl.textContent = newTitle;
                }
            };

            const deleteCompletedTasks = (columnId) => {
                const columnTitle = getColumnTitleElement(columnId)?.textContent || `Ïª¨Îüº ${columnId}`;
                const completedTasks = appData.tasks.filter(task => task.columnId === columnId && task.completed);

                if (completedTasks.length === 0) {
                    utils.showFeedback(`${columnTitle}Ïóê ÏôÑÎ£åÎêú Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§.`);
                    return;
                }

                if (confirm(`${columnTitle}Ïùò ÏôÑÎ£åÎêú Ìï≠Î™© ${completedTasks.length}Í∞úÎ•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                    const initialLength = appData.tasks.length;
                    appData.tasks = appData.tasks.filter(task => !(task.columnId === columnId && task.completed));
                    if (appData.tasks.length < initialLength) {
                        saveData();
                        renderBoard(); // Re-render needed
                        utils.showFeedback(`${columnTitle}ÏóêÏÑú ${completedTasks.length}Í∞úÏùò ÏôÑÎ£åÎêú Ìï≠Î™©ÏùÑ ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.`);
                    }
                }
            };

            const deleteAllTasksFromColumn = (columnId) => {
                const columnTitle = getColumnTitleElement(columnId)?.textContent || `Ïª¨Îüº ${columnId}`;
                const tasksInColumn = appData.tasks.filter(task => task.columnId === columnId).length;

                if (tasksInColumn === 0) {
                    utils.showFeedback(`${columnTitle}Ïóê ÏÇ≠Ï†úÌï† Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§.`);
                    return;
                }

                if (confirm(`${columnTitle}Ïùò Î™®Îì† Ìï≠Î™©(${tasksInColumn}Í∞ú)ÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå? Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§!`)) {
                    appData.tasks = appData.tasks.filter(task => task.columnId !== columnId);
                    saveData();
                    renderBoard(); // Re-render needed
                    utils.showFeedback(`${columnTitle}Ïùò Î™®Îì† Ìï≠Î™© ${tasksInColumn}Í∞úÎ•º ÏÇ≠Ï†úÌñàÏäµÎãàÎã§.`);
                }
            };

              // processAICommand Ìï®Ïàò ÎÇ¥ ÏàòÏ†ï
                // AI Ï≤òÎ¶¨ Ï§ë UI ÏÉÅÌÉú Í¥ÄÎ¶¨
                const setAIProcessing = (isProcessing) => {
                    executeAI.disabled = isProcessing;
                    executeAI.textContent = isProcessing ? 'Ï≤òÎ¶¨Ï§ë...' : 'Ïã§Ìñâ';
                    aiPrompt.disabled = isProcessing;
                    
                    // Ï≤òÎ¶¨ Ï§ëÏùº Îïå ÏãúÍ∞ÅÏ†Å ÌëúÏãú Ï∂îÍ∞Ä
                    if (isProcessing) {
                        aiResponse.innerHTML = "<div class='ai-thinking'>ü§î ÏÉùÍ∞Å Ï§ëÏûÖÎãàÎã§...</div>";
                    }
                };

                // AI Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨ - Í∞úÏÑ†Îêú ÌîÑÎ°¨ÌîÑÌä∏ ÏóîÏßÄÎãàÏñ¥ÎßÅ
                const processAICommand = async (prompt) => {
                    if (!prompt || prompt.trim() === "") {
                        aiResponse.innerHTML = "<div class='ai-error'>Î™ÖÎ†πÏñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.</div>";
                        return;
                    }
                    
                    setAIProcessing(true);
                    
                    try {
                        // ÏÇ¨Ïö©Ïûê Î™ÖÎ†πÏñ¥ Î∂ÑÏÑù Î∞è ÏùòÎèÑ ÌååÏïÖ
                        const commandType = await analyzeCommandIntent(prompt);
                        
                        // Î™ÖÎ†πÏñ¥ Ïú†ÌòïÏóê Îî∞Îùº Ï†ÅÏ†àÌïú Ï≤òÎ¶¨ ÏàòÌñâ
                        switch(commandType.type) {
                            case 'search':
                                await handleSearchCommand(prompt, commandType.keywords);
                                break;
                            case 'add':
                                await handleAddCommand(prompt, commandType.details);
                                break;
                            case 'update':
                                await handleUpdateCommand(prompt, commandType.taskInfo);
                                break;
                            case 'delete':
                                await handleDeleteCommand(prompt, commandType.taskInfo);
                                break;
                            case 'move':
                                await handleMoveCommand(prompt, commandType.taskInfo);
                                break;
                            case 'organize':
                                await handleOrganizeCommand(prompt);
                                break;
                                break;
                            case 'date':
                                await handleDateCommand(prompt, commandType.dateInfo);
                                break;
                            case 'unknown':
                                default:
                                await handleGenericCommand(prompt);    
                        }
                    } catch (error) {
                        console.error("AI Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:", error);
                        const errorMessage = error.message || "AI Ï≤òÎ¶¨ Ï§ë Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò Î∞úÏÉù";
                        aiResponse.innerHTML = `<div class='ai-error'>‚ö†Ô∏è ${utils.escapeHtml(errorMessage)}</div>`;
                    } finally {
                        setAIProcessing(false);
                    }
                };

                // Î™ÖÎ†πÏñ¥ ÏùòÎèÑ Î∂ÑÏÑù - ÏûëÏùÄ Î™®Îç∏ÏóêÏÑúÎèÑ Ïûò ÏûëÎèôÌïòÎäî Í∞ÑÍ≤∞Ìïú ÌîÑÎ°¨ÌîÑÌä∏
                const analyzeCommandIntent = async (prompt) => {
                    const systemMessage = `
                    ÎãπÏã†ÏùÄ ÏóÖÎ¨¥ Í¥ÄÎ¶¨ Ïï±Ïóê ÌÜµÌï©Îêú AI ÎπÑÏÑúÏûÖÎãàÎã§. ÏÇ¨Ïö©ÏûêÏùò ÏûÖÎ†•ÏùÑ Î∂ÑÏÑùÌïòÏó¨ Î¨¥ÏóáÏùÑ ÌïòÎ†§ÎäîÏßÄ ÏùòÎèÑÎ•º ÌååÏïÖÌï¥Ï£ºÏÑ∏Ïöî.
                    Í∞ÄÎä•Ìïú ÏùòÎèÑ Ïú†Ìòï: search(Í≤ÄÏÉâ/Ï∞æÍ∏∞), add(Ï∂îÍ∞Ä/ÏÉùÏÑ±), update(ÏàòÏ†ï/Î≥ÄÍ≤Ω), delete(ÏÇ≠Ï†ú), move(Ïù¥Îèô), organize(Ï†ïÎ¶¨/Ï†ïÎèà), date(ÎßàÍ∞êÏùº), unknown(Í∏∞ÌÉÄ),

                    JSON ÌòïÏãùÏúºÎ°ú Îã§ÏùåÍ≥º Í∞ôÏù¥ Í∞ÑÍ≤∞ÌïòÍ≤å ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
                    {
                    "type": "ÏùòÎèÑÏú†Ìòï",
                    "keywords": ["Í¥ÄÎ†®ÌÇ§ÏõåÎìú1", "Í¥ÄÎ†®ÌÇ§ÏõåÎìú2"], // Í≤ÄÏÉâÏñ¥ ÎòêÎäî Ï§ëÏöî Îã®Ïñ¥
                    "details": {}, // Ï∂îÍ∞ÄÌï† ÏóÖÎ¨¥ Ï†ïÎ≥¥(add ÌÉÄÏûÖÏùº Í≤ΩÏö∞)
                    "taskInfo": {}, // ÏûëÏóÖ Í¥ÄÎ†® Ï†ïÎ≥¥(update, delete, move ÌÉÄÏûÖÏùº Í≤ΩÏö∞)
                    "dateInfo": { // date ÌÉÄÏûÖÏùº Í≤ΩÏö∞
                        "action": "search/update/tag", // Ï∞æÍ∏∞/ÏàòÏ†ï/ÌÉúÍ∑∏Ï∂îÍ∞Ä Îì±
                        "condition": "overdue/today/tomorrow/thisWeek" // ÎßàÍ∞êÏùº Ï°∞Í±¥
                        }
                    }

                    ÏòàÏãú ÏùòÎèÑ ÌååÏïÖ:
                    - "ÌôçÍ∏∏Îèô Îã¥Îãπ ÏóÖÎ¨¥ Ï∞æÏïÑÏ§ò" ‚Üí {"type": "search", "keywords": ["ÌôçÍ∏∏Îèô", "Îã¥Îãπ"]}
                    - "ÌîÑÎ°úÏ†ùÌä∏ Í∏∞Ìöç ÏóÖÎ¨¥ Ï∂îÍ∞ÄÌï¥Ï§ò" ‚Üí {"type": "add", "details": {"title": "ÌîÑÎ°úÏ†ùÌä∏ Í∏∞Ìöç"}}
                    - "Î≥¥Í≥†ÏÑú ÎßàÍ∞êÏùº Îã§Ïùå Ï£ºÎ°ú Î≥ÄÍ≤Ω" ‚Üí {"type": "update", "taskInfo": {"title": "Î≥¥Í≥†ÏÑú", "field": "dueDate"}}
                    - "ÎßàÍ∞êÏùº ÏßÄÎÇú ÏóÖÎ¨¥ Ï∞æÏïÑÏ§ò" ‚Üí {"type": "date", "keywords": ["ÎßàÍ∞êÏùº", "ÏßÄÎÇú"], "dateInfo": {"action": "search", "condition": "overdue"}}
                    `;

                    try {
                        const response = await janAI.sendPrompt(prompt, systemMessage);
                        const aiContent = response?.choices?.[0]?.message?.content;
                        
                        if (!aiContent) throw new Error("ÏùòÎèÑ Î∂ÑÏÑù ÏùëÎãµÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.");
                        
                        // JSON Î∂ÄÎ∂Ñ Ï∂îÏ∂ú Î∞è ÌååÏã±
                        const jsonMatch = aiContent.match(/{[\s\S]*}/);
                        if (jsonMatch) {
                            try {
                                return JSON.parse(jsonMatch[0]);
                            } catch (parseError) {
                                console.warn("ÏùòÎèÑ Î∂ÑÏÑù JSON ÌååÏã± Ïã§Ìå®:", parseError);
                                // Í∏∞Î≥∏Í∞í Î∞òÌôò
                                return { type: "unknown" };
                            }
                        } else {
                            return { type: "unknown" };
                        }
                     }
                 catch (error) {
                        console.error("ÏùòÎèÑ Î∂ÑÏÑù Ïò§Î•ò:", error);
                        return { type: "unknown" };
                     }
                };

                // Í≤ÄÏÉâ Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨ - ÏûëÏùÄ Î™®Îç∏Ïóê ÏµúÏ†ÅÌôî
                const handleSearchCommand = async (originalPrompt, keywords) => {
                    // Í≤ÄÏÉâ Í¥ÄÎ†® taskÎßå ÌïÑÌÑ∞ÎßÅÌïòÏó¨ Ïª®ÌÖçÏä§Ìä∏ Ï†úÍ≥µ
                    const relevantTasks = appData.tasks.filter(task => {
                        const searchableText = [
                            task.title || "",
                            task.description || "",
                            task.assignees || "",
                            (task.tags || []).join(" ")
                        ].join(" ").toLowerCase();
                        
                        return keywords.some(keyword => 
                            searchableText.includes(keyword.toLowerCase())
                        );
                    });
                    
                    // Í≤ÄÏÉâ Í≤∞Í≥º Í∞úÏàòÏóê Îî∞Îùº Îã§Î•∏ ÌîÑÎ°¨ÌîÑÌä∏ ÏÇ¨Ïö©
                    const systemMessage = relevantTasks.length > 0 
                        ? `
                Îã§ÏùåÏùÄ '${keywords.join(", ")}' ÌÇ§ÏõåÎìúÏôÄ Í¥ÄÎ†®Îêú ÏóÖÎ¨¥ Î™©Î°ùÏûÖÎãàÎã§:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    assignees: t.assignees,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    completed: t.completed,
                    columnId: t.columnId
                })))}

                ÏÇ¨Ïö©Ïûê ÏßàÎ¨∏: "${originalPrompt}"

                ÏúÑ Ï†ïÎ≥¥Î•º Î∞îÌÉïÏúºÎ°ú ÏÇ¨Ïö©Ïûê ÏßàÎ¨∏Ïóê Ï†ïÌôïÌûà ÎãµÎ≥ÄÌï¥Ï£ºÏÑ∏Ïöî. 
                Î∞òÌôò ÌòïÏãùÏùÄ Îã§ÏùåÍ≥º Í∞ôÏäµÎãàÎã§:
                {
                "message": "Í≤ÄÏÉâ Í≤∞Í≥ºÏóê ÎåÄÌïú Í∞ÑÍ≤∞Ìïú ÎãµÎ≥Ä (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": false,
                "proposed_actions": [
                    {
                    "type": "info",
                    "payload": {
                        "details": [Í≤ÄÏÉâÎêú ÏóÖÎ¨¥ Î™©Î°ù ÎòêÎäî Ï†ïÎ≥¥]
                    }
                    }
                ]
                }
                `
                        : `
                '${keywords.join(", ")}' ÌÇ§ÏõåÎìúÏôÄ Í¥ÄÎ†®Îêú ÏóÖÎ¨¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.
                Îã§ÏùåÍ≥º Í∞ôÏù¥ ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
                {
                "message": "Í¥ÄÎ†® ÏóÖÎ¨¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
                "requires_confirmation": false,
                "proposed_actions": []
                }
                `;
                    
                    const response = await janAI.sendPrompt("Í≤ÄÏÉâ Í≤∞Í≥º Ï†ïÎ¶¨: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // ÏóÖÎ¨¥ Ï∂îÍ∞Ä Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨
                const handleAddCommand = async (originalPrompt, details) => {
                    // Ïª¨Îüº Ï†ïÎ≥¥Îßå Ï†úÍ≥µÌïòÏó¨ Ïª®ÌÖçÏä§Ìä∏ Í∞ÑÏÜåÌôî
                    const columns = appData.columns.map(c => ({
                        id: c.id,
                        title: c.title
                    }));
                    
                    const systemMessage = `
                Îã§ÏùåÏùÄ ÌòÑÏû¨ ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïª¨Îüº(Î≥¥Îìú) Î™©Î°ùÏûÖÎãàÎã§:
                ${JSON.stringify(columns)}

                ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠: "${originalPrompt}"

                ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÉà ÏóÖÎ¨¥Î•º Ï∂îÍ∞ÄÌïòÎ†§Í≥† Ìï©ÎãàÎã§. Ïñ¥Îäê Ïª¨ÎüºÏóê Ïñ¥Îñ§ ÎÇ¥Ïö©Ïùò ÏóÖÎ¨¥Î•º Ï∂îÍ∞ÄÌï¥Ïïº Ìï†ÏßÄ Î∂ÑÏÑùÌï¥Ï£ºÏÑ∏Ïöî.
                ÌïÑÏàò Ï†ïÎ≥¥: ÏóÖÎ¨¥Î™Ö(title), Ïª¨ÎüºID(columnId)
                ÏÑ†ÌÉù Ï†ïÎ≥¥: ÏÑ§Î™Ö(description), ÎßàÍ∞êÏùº(dueDate), Ï§ëÏöîÎèÑ(priority: low/medium/high), Îã¥ÎãπÏûê(assignees), ÌÉúÍ∑∏(tags)

                Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
                {
                "message": "ÏÉà ÏóÖÎ¨¥ Ï∂îÍ∞Ä Í¥ÄÎ†® ÌôïÏù∏ Î©îÏãúÏßÄ (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "add",
                    "payload": {
                        "columnId": "Ïª¨ÎüºID",
                        "title": "ÏóÖÎ¨¥Î™Ö",
                        "description": "ÏÑ§Î™Ö",
                        "dueDate": "YYYY-MM-DD",
                        "priority": "Ï§ëÏöîÎèÑ",
                        "assignees": "Îã¥ÎãπÏûê",
                        "tags": ["ÌÉúÍ∑∏1", "ÌÉúÍ∑∏2"]
                    }
                    }
                ]
                }

                Î™®Îì† ÌïÑÎìúÍ∞Ä ÌôïÏã§ÌïòÏßÄ ÏïäÎã§Î©¥, Í∞ÄÎä•Ìïú Î∂ÄÎ∂ÑÎßå Ï±ÑÏõåÏÑú ÏùëÎãµÌïòÏÑ∏Ïöî.
                `;
                    
                    const response = await janAI.sendPrompt("ÏóÖÎ¨¥ Ï∂îÍ∞Ä Ï≤òÎ¶¨: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // ÏóÖÎ¨¥ ÏàòÏ†ï Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨
                const handleUpdateCommand = async (originalPrompt, taskInfo) => {
                    // ÏàòÏ†ï ÎåÄÏÉÅ ÏóÖÎ¨¥ ÌïÑÌÑ∞ÎßÅ
                    let relevantTasks = [];
                    if (taskInfo && taskInfo.title) {
                        relevantTasks = appData.tasks.filter(task => 
                            task.title.toLowerCase().includes(taskInfo.title.toLowerCase())
                        );
                    } else {
                        // Ï†úÎ™© Ï†ïÎ≥¥Í∞Ä ÏóÜÏúºÎ©¥ ÏµúÍ∑º ÏóÖÎ¨¥ Î™á Í∞úÎßå ÌëúÏãú
                        relevantTasks = appData.tasks.slice(-5);
                    }
                    
                    const systemMessage = `
                Îã§ÏùåÏùÄ ÏàòÏ†ïÌï† Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÎäî ÏóÖÎ¨¥ Î™©Î°ùÏûÖÎãàÎã§:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    assignees: t.assignees,
                    columnId: t.columnId,
                    completed: t.completed
                })))}

                ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠: "${originalPrompt}"

                ÏàòÏ†ïÌï† ÏóÖÎ¨¥ÏôÄ Î≥ÄÍ≤ΩÌï† ÎÇ¥Ïö©ÏùÑ ÌååÏïÖÌï¥ Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
                {
                "message": "ÏóÖÎ¨¥ ÏàòÏ†ï ÌôïÏù∏ Î©îÏãúÏßÄ (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "update",
                    "payload": {
                        "taskId": "ÏóÖÎ¨¥ID",
                        "updates": {
                        "title": "ÏÉà ÏóÖÎ¨¥Î™Ö",
                        "description": "ÏÉà ÏÑ§Î™Ö",
                        "dueDate": "ÏÉà ÎßàÍ∞êÏùº",
                        "priority": "ÏÉà Ï§ëÏöîÎèÑ",
                        "assignees": "ÏÉà Îã¥ÎãπÏûê",
                        "completed": false/true,
                        "columnId": "ÏÉà Ïª¨ÎüºID",
                        "tags": ["ÏÉà ÌÉúÍ∑∏1", "ÏÉà ÌÉúÍ∑∏2"]
                        }
                    }
                    }
                ]
                }

                Î≥ÄÍ≤ΩÌï† ÌïÑÎìúÎßå Ìè¨Ìï®ÌïòÍ≥† ÎÇòÎ®∏ÏßÄÎäî ÏÉùÎûµÌïòÏÑ∏Ïöî.
                `;
                    
                    const response = await janAI.sendPrompt("ÏóÖÎ¨¥ ÏàòÏ†ï Ï≤òÎ¶¨: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // ÏóÖÎ¨¥ ÏÇ≠Ï†ú Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨
                const handleDeleteCommand = async (originalPrompt, taskInfo) => {
                    // ÏÇ≠Ï†ú ÎåÄÏÉÅ ÏóÖÎ¨¥ ÌïÑÌÑ∞ÎßÅ
                    let relevantTasks = [];
                    if (taskInfo && taskInfo.title) {
                        relevantTasks = appData.tasks.filter(task => 
                            task.title.toLowerCase().includes(taskInfo.title.toLowerCase())
                        );
                    } else {
                        // Ï†úÎ™© Ï†ïÎ≥¥Í∞Ä ÏóÜÏúºÎ©¥ ÏµúÍ∑º ÏóÖÎ¨¥ Î™á Í∞úÎßå ÌëúÏãú
                        relevantTasks = appData.tasks.slice(-5);
                    }
                    
                    const systemMessage = `
                Îã§ÏùåÏùÄ ÏÇ≠Ï†úÌï† Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÎäî ÏóÖÎ¨¥ Î™©Î°ùÏûÖÎãàÎã§:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    assignees: t.assignees
                })))}

                ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠: "${originalPrompt}"

                ÏÇ≠Ï†úÌï† ÏóÖÎ¨¥Î•º ÌååÏïÖÌï¥ Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
                {
                "message": "ÏóÖÎ¨¥ ÏÇ≠Ï†ú ÌôïÏù∏ Î©îÏãúÏßÄ (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "delete",
                    "payload": {
                        "taskId": "ÏóÖÎ¨¥ID"
                    }
                    }
                ]
                }

                ÏóÖÎ¨¥Î•º Ïó¨Îü¨Í∞ú ÏÇ≠Ï†úÌï¥Ïïº ÌïòÎäî Í≤ΩÏö∞ Ïó¨Îü¨ delete Ïï°ÏÖòÏùÑ Ìè¨Ìï®ÌïòÏÑ∏Ïöî.
                ÏóÖÎ¨¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏúºÎ©¥ "message"Ïóê Í∑∏ ÎÇ¥Ïö©ÏùÑ Ìè¨Ìï®ÌïòÍ≥† "proposed_actions"Îäî Îπà Î∞∞Ïó¥Î°ú ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.
                `;
                    
                    const response = await janAI.sendPrompt("ÏóÖÎ¨¥ ÏÇ≠Ï†ú Ï≤òÎ¶¨: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // ÏóÖÎ¨¥ Ïù¥Îèô Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨
                const handleMoveCommand = async (originalPrompt, taskInfo) => {
                    // Ïù¥Îèô ÎåÄÏÉÅ ÏóÖÎ¨¥ ÌïÑÌÑ∞ÎßÅ
                    let relevantTasks = [];
                    if (taskInfo && taskInfo.title) {
                        relevantTasks = appData.tasks.filter(task => 
                            task.title.toLowerCase().includes(taskInfo.title.toLowerCase())
                        );
                    } else {
                        // Ï†úÎ™© Ï†ïÎ≥¥Í∞Ä ÏóÜÏúºÎ©¥ ÏµúÍ∑º ÏóÖÎ¨¥ Î™á Í∞úÎßå ÌëúÏãú
                        relevantTasks = appData.tasks.slice(-5);
                    }
                    
                    // Ïª¨Îüº Ï†ïÎ≥¥ Ï†úÍ≥µ
                    const columns = appData.columns.map(c => ({
                        id: c.id,
                        title: c.title
                    }));
                    
                    const systemMessage = `
                Îã§ÏùåÏùÄ Ïù¥ÎèôÌï† Í∞ÄÎä•ÏÑ±Ïù¥ ÏûàÎäî ÏóÖÎ¨¥ Î™©Î°ùÏûÖÎãàÎã§:
                ${JSON.stringify(relevantTasks.map(t => ({
                    id: t.id,
                    title: t.title,
                    columnId: t.columnId
                })))}

                Í∞ÄÎä•Ìïú ÎåÄÏÉÅ Ïª¨Îüº Î™©Î°ù:
                ${JSON.stringify(columns)}

                ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠: "${originalPrompt}"

                Ïù¥ÎèôÌï† ÏóÖÎ¨¥ÏôÄ ÎåÄÏÉÅ Ïª¨ÎüºÏùÑ ÌååÏïÖÌï¥ Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
                {
                "message": "ÏóÖÎ¨¥ Ïù¥Îèô ÌôïÏù∏ Î©îÏãúÏßÄ (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": true,
                "proposed_actions": [
                    {
                    "type": "move",
                    "payload": {
                        "taskId": "ÏóÖÎ¨¥ID",
                        "targetColumnId": "ÎåÄÏÉÅÏª¨ÎüºID"
                    }
                    }
                ]
                }

                ÏóÖÎ¨¥ÎÇò ÎåÄÏÉÅ Ïª¨ÎüºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏúºÎ©¥ "message"Ïóê Í∑∏ ÎÇ¥Ïö©ÏùÑ Ìè¨Ìï®ÌïòÍ≥† "proposed_actions"Îäî Îπà Î∞∞Ïó¥Î°ú ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.
                `;
                    
                    const response = await janAI.sendPrompt("ÏóÖÎ¨¥ Ïù¥Îèô Ï≤òÎ¶¨: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // ÏóÖÎ¨¥ Ï†ïÎ¶¨ Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨
                const handleOrganizeCommand = async (originalPrompt) => {
                    // Ï†ïÎ¶¨ ÎåÄÏÉÅ ÏóÖÎ¨¥ÏôÄ Ïª¨Îüº Ï†ïÎ≥¥ Ï†úÍ≥µ
                    const columns = appData.columns.map(c => ({
                        id: c.id,
                        title: c.title
                    }));
                    
                    // Î™ÖÎ†πÏñ¥Ïóê Îî∞Îùº Ï†ÑÏ≤¥ ÎòêÎäî ÏùºÎ∂Ä ÏóÖÎ¨¥Îßå Ï†úÍ≥µ
                    let tasksToOrganize = appData.tasks;
                    if (originalPrompt.toLowerCase().includes("ÎßàÍ∞ê")) {
                        // ÎßàÍ∞êÏùº Í¥ÄÎ†® Î™ÖÎ†πÏù¥Î©¥ ÎßàÍ∞êÏùºÏù¥ ÏûàÎäî ÏóÖÎ¨¥Îßå ÌïÑÌÑ∞ÎßÅ
                        tasksToOrganize = appData.tasks.filter(t => t.dueDate);
                    } else if (originalPrompt.toLowerCase().includes("Ïö∞ÏÑ†ÏàúÏúÑ") || 
                            originalPrompt.toLowerCase().includes("Ï§ëÏöîÎèÑ")) {
                        // Ïö∞ÏÑ†ÏàúÏúÑ Í¥ÄÎ†® Î™ÖÎ†πÏù¥Î©¥ Ïö∞ÏÑ†ÏàúÏúÑ Ï†ïÎ≥¥Í∞Ä ÏûàÎäî ÏóÖÎ¨¥Îßå
                        tasksToOrganize = appData.tasks.filter(t => t.priority);
                    }
                    
                    const systemMessage = `
                ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠: "${originalPrompt}"

                Îã§ÏùåÏùÄ ÌòÑÏû¨ Ïª¨Îüº Î™©Î°ùÏûÖÎãàÎã§:
                ${JSON.stringify(columns)}

                Îã§ÏùåÏùÄ Ï†ïÎ¶¨Ìï† ÏóÖÎ¨¥ Î™©Î°ùÏûÖÎãàÎã§:
                ${JSON.stringify(tasksToOrganize.map(t => ({
                    id: t.id,
                    title: t.title,
                    dueDate: t.dueDate,
                    priority: t.priority,
                    assignees: t.assignees,
                    columnId: t.columnId,
                    completed: t.completed
                })))}

                ÏÇ¨Ïö©ÏûêÏùò ÏöîÏ≤≠Ïóê Îî∞Îùº ÏóÖÎ¨¥Î•º Ï†ïÎ¶¨Ìï¥Ï£ºÏÑ∏Ïöî. ÏóÖÎ¨¥ Ï†ïÎ¶¨Îäî Îã§Ïùå ÏûëÏóÖÏùÑ Ìè¨Ìï®Ìï† Ïàò ÏûàÏäµÎãàÎã§:
                1. ÏóÖÎ¨¥ Ïù¥Îèô (move)
                2. ÏóÖÎ¨¥ ÏóÖÎç∞Ïù¥Ìä∏ (update)
                3. ÏóÖÎ¨¥ ÏÇ≠Ï†ú (delete)

                ÌïÑÏöîÌïú ÏûëÏóÖÎì§ÏùÑ ÌååÏïÖÌï¥ Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
                {
                "message": "ÏóÖÎ¨¥ Ï†ïÎ¶¨ Ï†úÏïà ÏÑ§Î™Ö (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": true,
                "proposed_actions": [
                    // ÌïÑÏöîÌïú ÏûëÏóÖÎì§...
                ]
                }

                Ïï°ÏÖòÏùÄ ÏµúÎåÄ 5Í∞úÍπåÏßÄÎßå Ï†úÏïàÌïòÏÑ∏Ïöî.
                `;
                    
                    const response = await janAI.sendPrompt("ÏóÖÎ¨¥ Ï†ïÎ¶¨: " + originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // ÏùºÎ∞òÏ†ÅÏù∏ Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨ (Ïú†Ìòï Î∂ÑÎ•ò Ïã§Ìå® Ïãú)
                const handleGenericCommand = async (originalPrompt) => {
                    // ÏûëÏùÄ Î™®Îç∏ÏóêÍ≤å Î∂ÄÎã¥ÎêòÏßÄ ÏïäÎèÑÎ°ù ÏµúÏÜåÌïúÏùò Ï†ïÎ≥¥Îßå Ï†úÍ≥µ
                    const basicInfo = {
                        taskCount: appData.tasks.length,
                        columnCount: appData.columns.length,
                        columnNames: appData.columns.map(c => c.title)
                    };
                    
                    const systemMessage = `
                ÌòÑÏû¨ ÏóÖÎ¨¥ Í¥ÄÎ¶¨ Ïï± Ï†ïÎ≥¥:
                - Ï¥ù ÏóÖÎ¨¥ Ïàò: ${basicInfo.taskCount}Í∞ú
                - Ïª¨Îüº Ïàò: ${basicInfo.columnCount}Í∞ú
                - Ïª¨Îüº Ïù¥Î¶Ñ: ${basicInfo.columnNames.join(', ')}

                ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠: "${originalPrompt}"

                ÏÇ¨Ïö©ÏûêÏùò ÏöîÏ≤≠ÏùÑ Ïù¥Ìï¥ÌïòÍ≥† ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî. ÏûëÏóÖÏù¥ ÌïÑÏöîÌïòÎ©¥ Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌïòÍ≥†, 
                Îã®Ïàú ÏßàÎ¨∏Ïù¥Î©¥ Í∞ÑÎã®Ìïú Ï†ïÎ≥¥ ÏùëÎãµÏùÑ JSON ÌòïÏãùÏúºÎ°ú Ï†úÍ≥µÌï¥Ï£ºÏÑ∏Ïöî:

                {
                "message": "ÏÇ¨Ïö©Ïûê ÏöîÏ≤≠Ïóê ÎåÄÌïú ÏùëÎãµ (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": false/true,
                "proposed_actions": [] // ÌïÑÏöîÏãú ÏûëÏóÖ Ï†úÏïà
                }

                ÏûëÏóÖÏù¥ ÌïÑÏöî ÏóÜÎäî Îã®Ïàú ÏùëÎãµ:
                {
                "message": "ÏöîÏ≤≠Ïóê ÎåÄÌïú ÎãµÎ≥Ä (ÌïúÍµ≠Ïñ¥)",
                "requires_confirmation": false,
                "proposed_actions": []
                }
                `;
                    
                    const response = await janAI.sendPrompt(originalPrompt, systemMessage);
                    processAIResponse(response);
                };

                // ÎßàÍ∞êÏùº Í¥ÄÎ†® Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨
                    const handleDateCommand = async (originalPrompt, dateInfo) => {
                        // ÌòÑÏû¨ ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú ÎÇ†Ïßú ÌïÑÌÑ∞ÎßÅ Ï°∞Í±¥ ÏÉùÏÑ±
                        const today = new Date();
                        today.setHours(0, 0, 0, 0);
                        
                        // ÎßàÍ∞êÏùº Ï°∞Í±¥Ïóê Îî∞Î•∏ ÏóÖÎ¨¥ ÌïÑÌÑ∞ÎßÅ
                        let filteredTasks = [];
                        let conditionDescription = "";
                        
                        switch (dateInfo?.condition) {
                            case 'overdue':
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    return new Date(task.dueDate) < today;
                                });
                                conditionDescription = "ÎßàÍ∞êÏùºÏù¥ ÏßÄÎÇú";
                                break;
                                
                            case 'today':
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    const taskDate = new Date(task.dueDate);
                                    return taskDate.getFullYear() === today.getFullYear() &&
                                        taskDate.getMonth() === today.getMonth() &&
                                        taskDate.getDate() === today.getDate();
                                });
                                conditionDescription = "Ïò§Îäò ÎßàÍ∞êÏù∏";
                                break;
                                
                            case 'tomorrow':
                                const tomorrow = new Date(today);
                                tomorrow.setDate(today.getDate() + 1);
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    const taskDate = new Date(task.dueDate);
                                    return taskDate.getFullYear() === tomorrow.getFullYear() &&
                                        taskDate.getMonth() === tomorrow.getMonth() &&
                                        taskDate.getDate() === tomorrow.getDate();
                                });
                                conditionDescription = "ÎÇ¥Ïùº ÎßàÍ∞êÏù∏";
                                break;
                                
                            case 'thisWeek':
                                const weekEnd = new Date(today);
                                weekEnd.setDate(today.getDate() + (6 - today.getDay())); // Ïù¥Î≤à Ï£º ÏùºÏöîÏùº
                                filteredTasks = appData.tasks.filter(task => {
                                    if (!task.dueDate) return false;
                                    const taskDate = new Date(task.dueDate);
                                    return taskDate >= today && taskDate <= weekEnd;
                                });
                                conditionDescription = "Ïù¥Î≤à Ï£º ÎßàÍ∞êÏù∏";
                                break;
                                
                            default:
                                // Í∏∞Î≥∏: ÎßàÍ∞êÏùº ÏûàÎäî Î™®Îì† ÏóÖÎ¨¥
                                filteredTasks = appData.tasks.filter(task => task.dueDate);
                                conditionDescription = "ÎßàÍ∞êÏùºÏù¥ ÏûàÎäî";
                                break;
                        }
                        
                        // ÏûëÏóÖ Ïú†ÌòïÏóê Îî∞Î•∏ Ï≤òÎ¶¨
                        const actionType = dateInfo?.action || 'search';
                        
                        if (actionType === 'search') {
                            // Í≤ÄÏÉâ Í≤∞Í≥º Î∞òÌôò
                            const response = {
                                message: `${conditionDescription} ÏóÖÎ¨¥ ${filteredTasks.length}Í∞úÎ•º Ï∞æÏïòÏäµÎãàÎã§.`,
                                requires_confirmation: false,
                                proposed_actions: [
                                    {
                                        type: "info",
                                        payload: {
                                            details: filteredTasks.map(t => ({
                                                id: t.id,
                                                title: t.title,
                                                dueDate: t.dueDate,
                                                priority: t.priority,
                                                columnId: t.columnId,
                                                assignees: t.assignees
                                            }))
                                        }
                                    }
                                ]
                            };
                            
                            handleAIResponse(response);
                        } else if (actionType === 'tag') {
                            // ÌÉúÍ∑∏ Ï∂îÍ∞Ä Ï†úÏïà
                            const tagName = originalPrompt.match(/[''"]([^''"]+)[''"]/) ? 
                                            originalPrompt.match(/[''"]([^''"]+)[''"]/) :
                                            originalPrompt.includes('ÌÉúÍ∑∏') ? 
                                            originalPrompt.split('ÌÉúÍ∑∏')[1].trim().split(' ')[0] : 
                                            'ÎßàÍ∞êÏûÑÎ∞ï';
                                            
                            const actions = filteredTasks.map(task => ({
                                type: "update",
                                payload: {
                                    taskId: task.id,
                                    updates: {
                                        tags: [...(task.tags || []), tagName]
                                    }
                                }
                            }));
                            
                            if (actions.length > 0) {
                                const response = {
                                    message: `${conditionDescription} ÏóÖÎ¨¥ ${filteredTasks.length}Í∞úÏóê '${tagName}' ÌÉúÍ∑∏Î•º Ï∂îÍ∞ÄÌïòÏãúÍ≤†ÏäµÎãàÍπå?`,
                                    requires_confirmation: true,
                                    proposed_actions: actions
                                };
                                
                                handleAIResponse(response);
                            } else {
                                handleAIResponse({
                                    message: `${conditionDescription} ÏóÖÎ¨¥Í∞Ä ÏóÜÏäµÎãàÎã§.`,
                                    requires_confirmation: false,
                                    proposed_actions: []
                                });
                            }
                        }
                    };
                                        

                // AI ÏùëÎãµ Ï≤òÎ¶¨ - Í≥µÌÜµ Ìï®Ïàò
                const processAIResponse = (response) => {
                    const aiContent = response?.choices?.[0]?.message?.content;
                    
                    if (!aiContent) {
                        aiResponse.innerHTML = "<div class='ai-error'>AIÎ°úÎ∂ÄÌÑ∞ Ïú†Ìö®Ìïú ÏùëÎãµÏùÑ Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.</div>";
                        return;
                    }
                    
                    // JSON Î∂ÄÎ∂Ñ Ï∂îÏ∂ú
                    const jsonMatch = aiContent.match(/{[\s\S]*}/);
                    if (jsonMatch) {
                        try {
                            const parsedResponse = JSON.parse(jsonMatch[0]);
                            handleAIResponse(parsedResponse);
                        } catch (parseError) {
                            console.error("AI ÏùëÎãµ JSON ÌååÏã± Ïò§Î•ò:", parseError);
                            
                            // ÌååÏã± Ïã§Ìå®Ïãú ÌÖçÏä§Ìä∏ Í∑∏ÎåÄÎ°ú ÌëúÏãú
                            aiResponse.innerHTML = `
                                <div class='ai-error'>ÏùëÎãµ ÌòïÏãùÏóê Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§. ÏõêÎ≥∏ ÏùëÎãµ:</div>
                                <div class='ai-response-text'>${utils.escapeHtml(aiContent)}</div>
                            `;
                        }
                    } else {
                        // JSONÏù¥ ÏïÑÎãå ÌÖçÏä§Ìä∏ ÏùëÎãµ Ï≤òÎ¶¨
                        aiResponse.innerHTML = `<div class='ai-response-text'>${utils.escapeHtml(aiContent)}</div>`;
                    }
                };

                // AI ÏùëÎãµ Ï≤òÎ¶¨ Î∞è UI ÏóÖÎç∞Ïù¥Ìä∏
                let storedProposedActions = []; // ÌôïÏù∏ ÎåÄÍ∏∞ Ï§ëÏù∏ ÏûëÏóÖÏùÑ ÏûÑÏãú Ï†ÄÏû•

                const handleAIResponse = (response) => {
                    aiResponse.innerHTML = ''; // Ïù¥Ï†Ñ ÏùëÎãµ ÏßÄÏö∞Í∏∞
                    storedProposedActions = []; // Ïù¥Ï†Ñ Ïï°ÏÖò Ï†úÏïà Ï¥àÍ∏∞Ìôî

                    const message = response?.message || "AIÎ°úÎ∂ÄÌÑ∞ Î©îÏãúÏßÄÎ•º Î∞õÏßÄ Î™ªÌñàÏäµÎãàÎã§.";
                    const requiresConfirmation = response?.requires_confirmation === true; // Î™ÖÏãúÏ†ÅÏúºÎ°ú trueÏù∏ÏßÄ ÌôïÏù∏
                    const proposedActions = response?.proposed_actions || [];

                    // Î©îÏãúÏßÄ ÌëúÏãú
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'ai-response-text';
                    messageDiv.textContent = message; // textContentÎ°ú ÏïàÏ†ÑÌïòÍ≤å ÌëúÏãú
                    aiResponse.appendChild(messageDiv);

                    // 'info' ÌÉÄÏûÖ Ïï°ÏÖò Ï≤òÎ¶¨ (Ï†ïÎ≥¥ÏÑ± Î©îÏãúÏßÄ Ï∂îÍ∞Ä ÌëúÏãú)
                    const infoAction = proposedActions.find(a => a.type === 'info');
                    if (infoAction && infoAction.payload?.details) {
                        const detailsDiv = document.createElement('div');
                        detailsDiv.style.marginTop = '10px';
                        detailsDiv.style.fontSize = '0.9em';
                        detailsDiv.style.opacity = '0.8';
                        
                        if (Array.isArray(infoAction.payload.details)) {
                            detailsDiv.innerHTML = '<strong>Í¥ÄÎ†® ÏóÖÎ¨¥:</strong><ul>' +
                                infoAction.payload.details.map(taskInfo =>
                                    `<li>${utils.escapeHtml(taskInfo.title || 'Ï†úÎ™© ÏóÜÏùå')} ${
                                        taskInfo.dueDate ? `(ÎßàÍ∞êÏùº: ${taskInfo.dueDate})` : ''
                                    } ${
                                        taskInfo.priority ? `(Ï§ëÏöîÎèÑ: ${taskInfo.priority})` : ''
                                    }</li>`
                                ).join('') + '</ul>';
                        } else if (typeof infoAction.payload.details === 'string') {
                            detailsDiv.innerHTML = `<strong>Ï†ïÎ≥¥:</strong> ${utils.escapeHtml(infoAction.payload.details)}`;
                        }
                        aiResponse.appendChild(detailsDiv);
                    }

                    if (requiresConfirmation && proposedActions.length > 0) {
                        // ÌôïÏù∏/Ï∑®ÏÜå Î≤ÑÌäº Ï∂îÍ∞Ä
                        storedProposedActions = proposedActions; // Ïã§ÌñâÌï† Ïï°ÏÖò Ï†ÄÏû•

                        const confirmationDiv = document.createElement('div');
                        confirmationDiv.style.marginTop = '15px';
                        confirmationDiv.style.display = 'flex';
                        confirmationDiv.style.gap = '10px';

                        const confirmButton = document.createElement('button');
                        confirmButton.textContent = 'ÌôïÏù∏ (Ïã§Ìñâ)';
                        confirmButton.className = 'ai-btn ai-btn--confirm';
                        confirmButton.onclick = () => {
                            aiResponse.innerHTML = `<div class='ai-thinking'>‚è≥ ÏûëÏóÖÏùÑ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§...</div>`;
                            // Ï†ÄÏû•Îêú Ïï°ÏÖò Ïã§Ìñâ
                            executeProposedAIActions(storedProposedActions);
                            storedProposedActions = []; // Ïã§Ìñâ ÌõÑ Ï¥àÍ∏∞Ìôî
                        };

                        const cancelButton = document.createElement('button');
                        cancelButton.textContent = 'Ï∑®ÏÜå';
                        cancelButton.className = 'ai-btn ai-btn--cancel ai-btn--secondary';
                        cancelButton.onclick = () => {
                            aiResponse.innerHTML = `<div class='ai-info'>‚ÑπÔ∏è ÏûëÏóÖÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.</div>`;
                            storedProposedActions = []; // Ï∑®ÏÜå Ïãú Ï¥àÍ∏∞Ìôî
                        };

                        confirmationDiv.appendChild(confirmButton);
                        confirmationDiv.appendChild(cancelButton);
                        aiResponse.appendChild(confirmationDiv);
                    } else if (!requiresConfirmation && proposedActions.length === 0 && !infoAction) {
                        // ÏûëÏóÖ ÏóÜÏùå & Ï†ïÎ≥¥ ÏóÜÏùå Î©îÏãúÏßÄ Í∞ïÏ°∞
                        messageDiv.style.fontStyle = 'italic';
                    }
                };

                // Ï†úÏïàÎêú AI Ïï°ÏÖò Ïã§Ìñâ
                const executeProposedAIActions = (actions) => {
                    let performedActions = false;
                    let actionResults = []; // Í∞Å Ïï°ÏÖòÏùò ÏÑ±Í≥µ/Ïã§Ìå® Î©îÏãúÏßÄ

                    try {
                        actions.forEach(action => {
                            const { type, payload } = action;
                            let resultMessage = '';
                            
                            try {
                                switch (type) {
                                    case 'add':
                                        if (payload.columnId && payload.title) {
                                            addTask({
                                                columnId: payload.columnId,
                                                title: payload.title,
                                                description: payload.description,
                                                dueDate: payload.dueDate,
                                                priority: payload.priority || 'medium',
                                                assignees: payload.assignees,
                                                tags: payload.tags || []
                                            });
                                            resultMessage = `‚úÖ '${payload.title}' ÏóÖÎ¨¥ Ï∂îÍ∞Ä ÏôÑÎ£å.`;
                                            performedActions = true;
                                        } else {
                                            throw new Error("Ï∂îÍ∞Ä Ïï°ÏÖòÏóê ÌïÑÏöîÌïú Ï†ïÎ≥¥Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                                        }
                                        break;
                                        
                                    case 'update':
                                        if (payload.taskId && payload.updates) {
                                            const taskIndex = appData.tasks.findIndex(t => t.id === payload.taskId);
                                            if (taskIndex > -1) {
                                                const task = appData.tasks[taskIndex];
                                                updateTask(payload.taskId, { ...task, ...payload.updates });
                                                resultMessage = `‚úÖ '${task.title}' ÏóÖÎ¨¥ ÏàòÏ†ï ÏôÑÎ£å.`;
                                                performedActions = true;
                                            } else {
                                                throw new Error(`ID '${payload.taskId}'Ïùò ÏóÖÎ¨¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
                                            }
                                        } else {
                                            throw new Error("ÏàòÏ†ï Ïï°ÏÖòÏóê ÌïÑÏöîÌïú Ï†ïÎ≥¥Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                                        }
                                        break;
                                        
                                    case 'delete':
                                        if (payload.taskId) {
                                            const task = appData.tasks.find(t => t.id === payload.taskId);
                                            if (task) {
                                                const taskTitle = task.title; // ÏÇ≠Ï†ú Ï†Ñ Ï†úÎ™© Ï†ÄÏû•
                                                deleteTask(payload.taskId);
                                                resultMessage = `‚úÖ '${taskTitle}' ÏóÖÎ¨¥ ÏÇ≠Ï†ú ÏôÑÎ£å.`;
                                                performedActions = true;
                                            } else {
                                                throw new Error(`ID '${payload.taskId}'Ïùò ÏóÖÎ¨¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.`);
                                            }
                                        } else {
                                            throw new Error("ÏÇ≠Ï†ú Ïï°ÏÖòÏóê ÌïÑÏöîÌïú Ï†ïÎ≥¥Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                                        }
                                        break;
                                        
                                    case 'move':
                                        if (payload.taskId && payload.targetColumnId) {
                                            const task = appData.tasks.find(t => t.id === payload.taskId);
                                            const column = appData.columns.find(c => c.id === payload.targetColumnId);
                                            
                                            if (task && column) {
                                                moveTask(payload.taskId, payload.targetColumnId);
                                                resultMessage = `‚úÖ '${task.title}' ÏóÖÎ¨¥Î•º '${column.title}' Ïª¨ÎüºÏúºÎ°ú Ïù¥Îèô ÏôÑÎ£å.`;
                                                performedActions = true;
                                            } else {
                                                throw new Error("Ïù¥ÎèôÌï† ÏóÖÎ¨¥ ÎòêÎäî ÎåÄÏÉÅ Ïª¨ÎüºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
                                            }
                                        } else {
                                            throw new Error("Ïù¥Îèô Ïï°ÏÖòÏóê ÌïÑÏöîÌïú Ï†ïÎ≥¥Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.");
                                        }
                                        break;
                                        
                                    case 'info':
                                        // Ï†ïÎ≥¥ Ïï°ÏÖòÏùÄ Î≥ÑÎèÑ Ï≤òÎ¶¨ ÌïÑÏöî ÏóÜÏùå
                                        resultMessage = `‚ÑπÔ∏è Ï†ïÎ≥¥ Ï°∞Ìöå ÏôÑÎ£å.`;
                                        break;
                                        
                                    default:
                                        console.warn("Ïïå Ïàò ÏóÜÎäî AI Ïï°ÏÖò ÌÉÄÏûÖ:", type);
                                        resultMessage = `‚ö†Ô∏è Ïïå Ïàò ÏóÜÎäî Ïï°ÏÖò ÌÉÄÏûÖ '${type}'`;
                                }
                                
                                actionResults.push(resultMessage);
                            } catch (actionError) {
                                console.error(`Error executing AI action ${type}:`, actionError);
                                actionResults.push(`‚ùå ${type} Ïï°ÏÖò Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: ${actionError.message}`);
                            }
                        });

                        if (performedActions) {
                            saveData(); // Î™®Îì† Ïï°ÏÖò Ï≤òÎ¶¨ ÌõÑ Ìïú Î≤àÎßå Ï†ÄÏû•
                            renderBoard(); // UI ÏóÖÎç∞Ïù¥Ìä∏
                            
                            // ÏÑ±Í≥µ Î©îÏãúÏßÄ ÌëúÏãú
                            aiResponse.innerHTML = `<div class='ai-success'>${actionResults.filter(r => r.startsWith('‚úÖ') || r.startsWith('‚ÑπÔ∏è')).join('<br>')}</div>`;
                            
                            if(actionResults.some(r => r.startsWith('‚ùå') || r.startsWith('‚ö†Ô∏è'))) {
                                aiResponse.innerHTML += `<div class='ai-error' style='margin-top: 10px;'><strong>ÏùºÎ∂Ä ÏûëÏóÖ Ïã§Ìå®:</strong><br>${actionResults.filter(r => r.startsWith('‚ùå') || r.startsWith('‚ö†Ô∏è')).join('<br>')}</div>`;
                            }
                        } else {
                            // Ïã§ÌñâÎêú ÏûëÏóÖÏù¥ ÏóÜÏùÑ Îïå
                            if (actionResults.some(r => r.startsWith('‚ùå') || r.startsWith('‚ö†Ô∏è'))) {
                                aiResponse.innerHTML = `<div class='ai-error'><strong>ÏûëÏóÖ Ïã§Ìå®:</strong><br>${actionResults.filter(r => r.startsWith('‚ùå') || r.startsWith('‚ö†Ô∏è')).join('<br>')}</div>`;
                            } else {
                                aiResponse.innerHTML = `<div class='ai-info'>‚ÑπÔ∏è ÏöîÏ≤≠ÌïòÏã† ÏûëÏóÖÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§ (Îç∞Ïù¥ÌÑ∞ Î≥ÄÍ≤Ω ÏóÜÏùå).</div>`;
                            }
                        }
                    } catch (globalError) {
                        console.error("Error during AI action execution:", globalError);
                        aiResponse.innerHTML = `<div class='ai-error'>‚ö†Ô∏è AI Ïï°ÏÖò Ïã§Ìñâ Ï§ë ÏòàÏô∏ Î∞úÏÉù: ${utils.escapeHtml(globalError.message)}</div>`;
                    }
                };

                // AIÎ°ú ÏóÖÎ¨¥ Ï†ïÎ¶¨ Í∏∞Îä•
                const organizeTasksWithAI = async () => {
                    await processAICommand("ÏóÖÎ¨¥Î•º Ï†ïÎ¶¨Ìï¥Ï£ºÏÑ∏Ïöî: ÎßàÍ∞êÏùºÏù¥ ÏßÄÎÇú ÏóÖÎ¨¥Îäî 'Ï§ëÏöîÎèÑ: ÎÜíÏùå'ÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÍ≥†, Ïò§Îäò ÎßàÍ∞êÏù∏ ÏóÖÎ¨¥Îäî 'Ïò§ÎäòÎßàÍ∞ê' ÌÉúÍ∑∏Î•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî. ÏôÑÎ£åÎêú ÏóÖÎ¨¥Îäî Îß® ÏïÑÎûòÎ°ú Ï†ïÎ†¨Ìï¥Ï£ºÏÑ∏Ïöî.");
                };
            // --- Modal Handling ---
            // Store reference to the element that was focused before opening the modal
            let elementFocusedBeforeModal;

            const openTaskModal = (mode = 'add', columnId = null, taskId = null) => {
                elementFocusedBeforeModal = document.activeElement; // Store focus

                taskForm.reset();
                tagsContainer.innerHTML = '';
                currentTags = [];
                taskModal.setAttribute('aria-hidden', 'false'); // Make modal accessible

                const today = new Date().toISOString().split('T')[0];
                taskForm.taskDueDate.value = today; // Default due date
                taskForm.taskPriority.value = 'medium'; // Default priority

                if (mode === 'edit' && taskId) {
                    const task = getTaskDataById(taskId);
                    if (task) {
                        modalTitle.textContent = 'ÏóÖÎ¨¥ ÏàòÏ†ï';
                        taskForm.taskId.value = task.id;
                        taskForm.columnId.value = task.columnId;
                        taskForm.taskTitle.value = task.title;
                        taskForm.taskDescription.value = task.description || '';
                        taskForm.taskDueDate.value = task.dueDate || ''; // Allow empty date
                        taskForm.taskAssignees.value = task.assignees || '';
                        taskForm.taskPriority.value = task.priority || 'medium';
                        if (task.tags && task.tags.length > 0) {
                            currentTags = [...task.tags];
                            renderTags();
                        }
                    } else {
                        console.error("ÏóÖÎ¨¥ ÏàòÏ†ï Ïò§Î•ò: IDÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå", taskId);
                        utils.showFeedback("ÏàòÏ†ïÌïòÎ†§Îäî ÏóÖÎ¨¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", 'error');
                        taskModal.setAttribute('aria-hidden', 'true'); // Hide if error
                        return; // Don't open modal
                    }
                } else {
                    const columnName = getColumnTitleElement(columnId)?.textContent || 'ÏÉà';
                    modalTitle.textContent = `${columnName} ÏóÖÎ¨¥ Ï∂îÍ∞Ä`;
                    taskForm.taskId.value = '';
                    taskForm.columnId.value = columnId;
                     taskForm.taskDueDate.value = ''; // Start with empty date for new tasks
                }

                taskModal.classList.add('visible');
                requestAnimationFrame(() => { // Wait for display:flex to apply
                    taskModal.classList.add('modal--visible');
                    taskForm.taskTitle.focus(); // Set focus to the first input
                     // Basic focus trap concept (needs more robust implementation for production)
                     // Add keydown listener to modal content to trap focus
                });
            };

            const closeModal = () => {
                taskModal.classList.remove('modal--visible');
                taskModal.setAttribute('aria-hidden', 'true');

                // Wait for transition to finish before removing 'visible' (display: none)
                 // The timeout should match the CSS transition duration
                setTimeout(() => {
                    taskModal.classList.remove('visible');
                    if (elementFocusedBeforeModal) {
                        elementFocusedBeforeModal.focus(); // Restore focus
                    }
                }, 300); // Match CSS transition duration
            };

            const openDetailModal = (taskId) => {
                elementFocusedBeforeModal = document.activeElement;
                const task = getTaskDataById(taskId);
                if (!task) return;

                // Use textContent or utils.escapeHtml for security
                detailContent.innerHTML = `
                    <h3 id="taskDetailTitle">${utils.escapeHtml(task.title)}</h3>
                    <p><strong>ÏÉÅÌÉú:</strong> ${task.completed ? 'ÏôÑÎ£å' : 'ÏßÑÌñâÏ§ë'}</p>
                    <p><strong>Ï§ëÏöîÎèÑ:</strong> ${task.priority || 'Î≥¥ÌÜµ'}</p>
                    <p><strong>ÎßàÍ∞êÏùº:</strong> ${utils.formatDueDateForDisplay(task.dueDate)} (${task.dueDate || 'ÎØ∏ÏßÄÏ†ï'})</p>
                    <p><strong>Îã¥ÎãπÏûê:</strong> ${utils.escapeHtml(task.assignees || 'ÎØ∏ÏßÄÏ†ï')}</p>
                    ${task.tags && task.tags.length > 0 ?
                        `<p><strong>ÌÉúÍ∑∏:</strong> ${task.tags.map(t => `<span class="task__tag">${utils.escapeHtml(t)}</span>`).join(' ')}</p>` : ''}
                    <p><strong>ÏÑ§Î™Ö:</strong></p>
                    <p style="white-space: pre-wrap; word-wrap: break-word;">${utils.escapeHtml(task.description || 'ÏóÜÏùå')}</p>
                `;

                detailModal.setAttribute('aria-hidden', 'false');
                detailModal.classList.add('visible');
                requestAnimationFrame(() => {
                    detailModal.classList.add('modal--visible');
                    detailModal.querySelector('.modal__close').focus(); // Focus close button
                });
            };

            const closeDetailModal = () => {
                detailModal.classList.remove('modal--visible');
                detailModal.setAttribute('aria-hidden', 'true');
                setTimeout(() => {
                    detailModal.classList.remove('visible');
                     if (elementFocusedBeforeModal) {
                        elementFocusedBeforeModal.focus();
                    }
                }, 300);
            };

            // --- Tag Management ---
            const addTag = (tagText) => {
                const tag = tagText.trim();
                if (tag && !currentTags.includes(tag)) {
                    if (currentTags.length >= 10) { // Limit tags?
                        utils.showFeedback("ÌÉúÍ∑∏Îäî ÏµúÎåÄ 10Í∞úÍπåÏßÄ Ï∂îÍ∞ÄÌï† Ïàò ÏûàÏäµÎãàÎã§.", 'warning');
                        return;
                    }
                    currentTags.push(tag);
                    renderTags();
                }
                tagInput.value = ''; // Clear input after adding
            };

            const removeTag = (tagIndex) => {
                if (tagIndex >= 0 && tagIndex < currentTags.length) {
                     const removedTag = currentTags.splice(tagIndex, 1)[0];
                     renderTags();
                     // utils.showFeedback(`'${removedTag}' ÌÉúÍ∑∏ ÏÇ≠Ï†úÎê®.`); // Maybe too noisy
                }
            };

            const renderTags = () => {
                tagsContainer.innerHTML = '';
                if (currentTags.length === 0) {
                    // Optional: Show placeholder text when no tags
                    // tagsContainer.innerHTML = '<p style="font-style: italic; color: var(--text-secondary-color);">ÌÉúÍ∑∏Í∞Ä ÏóÜÏäµÎãàÎã§.</p>';
                    return;
                }
                currentTags.forEach((tag, index) => {
                    const tagEl = document.createElement('span');
                    tagEl.className = 'form-group__tag';
                    tagEl.textContent = tag; // Set text content directly

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button'; // Prevent form submission
                    removeBtn.className = 'form-group__tag-remove';
                    removeBtn.innerHTML = '√ó';
                    removeBtn.dataset.tagIndex = index;
                    removeBtn.setAttribute('aria-label', `${tag} ÌÉúÍ∑∏ ÏÇ≠Ï†ú`);
                    removeBtn.addEventListener('click', () => removeTag(index)); // Add listener here

                    tagEl.appendChild(removeBtn);
                    tagsContainer.appendChild(tagEl);
                });
            };

            // --- Drag and Drop ---
            const handleDragStart = (e) => {
                // Check if dragging is initiated from a valid handle or the task itself
                // For example, prevent drag start if clicking on input/button inside task
                if (e.target.closest('input, button, textarea, select')) {
                    e.preventDefault();
                    return;
                }
                draggedTask = e.target;
                setTimeout(() => draggedTask.classList.add('task--dragging'), 0);
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggedTask.dataset.taskId); // Required for Firefox
            };

            const handleDragEnd = () => {
                if (draggedTask) {
                    draggedTask.classList.remove('task--dragging');
                }
                removePlaceholder(); // Ensure placeholder is removed
                board.querySelectorAll('.column__content--drag-over').forEach(col => {
                    col.classList.remove('column__content--drag-over');
                });
                draggedTask = null;
            };

            const handleDragOver = (e) => {
                e.preventDefault(); // Necessary to allow drop
                if (!draggedTask) return;
                e.dataTransfer.dropEffect = 'move';

                const columnContent = e.target.closest('.column__content');
                if (!columnContent) return;

                columnContent.classList.add('column__content--drag-over'); // Highlight column

                const afterElement = getDragAfterElement(columnContent, e.clientY);
                updatePlaceholder(columnContent, afterElement);
            };

            const handleDragLeave = (e) => {
                const columnContent = e.target.closest('.column__content');
                // Check if the mouse is truly leaving the column content area
                if (columnContent && !columnContent.contains(e.relatedTarget)) {
                    columnContent.classList.remove('column__content--drag-over');
                    removePlaceholder();
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                const columnContent = e.target.closest('.column__content');
                if (columnContent && draggedTask) {
                    columnContent.classList.remove('column__content--drag-over');
                    const targetColumnId = columnContent.dataset.columnId;
                    const taskId = draggedTask.dataset.taskId;

                    const placeholder = columnContent.querySelector('.task--placeholder');
                    const insertBeforeEl = placeholder ? placeholder.nextElementSibling : null;
                    const insertBeforeTaskId = insertBeforeEl?.dataset.taskId;

                    removePlaceholder();

                    // Only move if the position actually changed
                    if (draggedTask.parentElement !== columnContent || draggedTask.nextElementSibling !== insertBeforeEl) {
                         moveTask(taskId, targetColumnId, insertBeforeTaskId);
                         // Optimistic UI update (move DOM element immediately) + background data update
                         // columnContent.insertBefore(draggedTask, insertBeforeEl);
                         // updateColumnCounter(originalColumnId); // Need originalColumnId
                         // updateColumnCounter(targetColumnId);
                         // // Then call a function to update the data model without full re-render
                         // updateTaskDataPosition(taskId, targetColumnId, insertBeforeTaskId);
                    }
                }
                 handleDragEnd(); // Clean up
            };

            const getDragAfterElement = (container, y) => {
                const draggableElements = [...container.querySelectorAll('.task:not(.task--dragging):not(.task--placeholder)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            };

            // Placeholder functions
            const createPlaceholder = () => {
                if (!dragPlaceholder) {
                    dragPlaceholder = document.createElement('div');
                    dragPlaceholder.className = 'task task--placeholder';
                    // Match height roughly to the dragged task?
                    if (draggedTask) {
                         dragPlaceholder.style.height = `${draggedTask.offsetHeight}px`;
                    }
                }
                return dragPlaceholder;
            };

            const removePlaceholder = () => {
                if (dragPlaceholder && dragPlaceholder.parentNode) {
                    dragPlaceholder.parentNode.removeChild(dragPlaceholder);
                }
                // dragPlaceholder = null; // Don't nullify, reuse the element
            };

            const updatePlaceholder = (container, afterElement) => {
                removePlaceholder(); // Remove from previous position first
                const placeholder = createPlaceholder();
                if (afterElement) {
                    container.insertBefore(placeholder, afterElement);
                } else {
                    container.appendChild(placeholder); // Append if no element after
                }
            };


            // --- Context Menu ---
            const showColumnMenu = (buttonElement, columnId) => {
                closeColumnMenu(); // Í∏∞Ï°¥ Î©îÎâ¥ Îã´Í∏∞

                currentMenu = document.createElement('div');
                currentMenu.className = 'menu';
                currentMenu.setAttribute('role', 'menu');

                const createMenuItem = (text, action, ariaLabel) => {
                    const item = document.createElement('div');
                    item.className = 'menu__item';
                    item.textContent = text;
                    item.setAttribute('role', 'menuitem');
                    item.tabIndex = -1; // Make focusable by script if needed
                    item.onclick = () => {
                        action();
                        closeColumnMenu();
                    };
                    if (ariaLabel) item.setAttribute('aria-label', ariaLabel);
                    return item;
                };

                currentMenu.appendChild(createMenuItem('ÏôÑÎ£åÎêú Ìï≠Î™© ÏÇ≠Ï†ú', () => deleteCompletedTasks(columnId)));
                currentMenu.appendChild(createMenuItem('Ï†ÑÏ≤¥ ÏÇ≠Ï†ú', () => deleteAllTasksFromColumn(columnId), 'Í≤ΩÍ≥†: Ìï¥Îãπ Ïª¨ÎüºÏùò Î™®Îì† Ìï≠Î™©ÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§'));

                const separator = document.createElement('div');
                separator.className = 'menu__separator';
                separator.setAttribute('role', 'separator');
                currentMenu.appendChild(separator);

                currentMenu.appendChild(createMenuItem('ÌÖçÏä§Ìä∏ ÌååÏùºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞', () => exportColumnToText(columnId)));

                document.body.appendChild(currentMenu);

                // Positioning
                const btnRect = buttonElement.getBoundingClientRect(); // <-- Î≥ÄÍ≤Ω: Í∏∞Ï§Ä ÏöîÏÜåÎ•º buttonElementÎ°ú
                const menuRect = currentMenu.getBoundingClientRect(); // Î©îÎâ¥ ÏûêÏ≤¥Ïùò ÌÅ¨Í∏∞ (Î≥ÄÍ≤Ω ÏóÜÏùå)
                let top = btnRect.bottom + window.scrollY + 2;
                let left = btnRect.left + window.scrollX;

                // Adjust if menu goes off-screen
                if (left + menuRect.width > window.innerWidth - 10) {
                    left = btnRect.right + window.scrollX - menuRect.width;
                }
                if (top + menuRect.height > window.innerHeight - 10) {
                    top = btnRect.top + window.scrollY - menuRect.height - 2;
                }

                currentMenu.style.top = `${Math.max(0, top)}px`;
                currentMenu.style.left = `${Math.max(0, left)}px`;

                requestAnimationFrame(() => {
                     currentMenu.classList.add('menu--visible');
                     currentMenu.querySelector('.menu__item')?.focus(); // Focus first item?
                });

                // --- Ïô∏Î∂Ä ÌÅ¥Î¶≠ Î∞è ESC ÌÇ§ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä (handleClickOutsideMenuÏóê buttonElement Ï†ÑÎã¨) ---
                setTimeout(() => {
                    // document.addEventListener('click', handleClickOutsideMenu, { capture: true, once: true }); // Ïù¥Ï†Ñ ÏΩîÎìú
                    // ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Ïóê buttonElement Ï†ïÎ≥¥ÎèÑ Ìï®Íªò Ï†ÑÎã¨
                    document.addEventListener('click', (e) => handleClickOutsideMenu(e, buttonElement), { capture: true, once: true });
                    document.addEventListener('keydown', handleMenuKeyDown, { capture: true }); // Keydown Ìï∏Îì§Îü¨Îäî Î≥ÄÍ≤Ω ÌïÑÏöî ÏóÜÏùÑ Ïàò ÏûàÏùå
                }, 0);
            };
            const closeColumnMenu = () => {
                if (currentMenu) {
                    currentMenu.classList.remove('menu--visible');
                     document.removeEventListener('keydown', handleMenuKeyDown, { capture: true });
                    // Remove from DOM after transition
                    currentMenu.addEventListener('transitionend', () => {
                        currentMenu?.remove(); // Check if still exists
                        currentMenu = null;
                    }, { once: true });
                }
                 document.removeEventListener('click', handleClickOutsideMenu, { capture: true }); // Ensure listener removed
            };

            const handleClickOutsideMenu = (event) => {
                if (currentMenu && !currentMenu.contains(event.target) && !event.target.closest('.action-btn--menu')) {
                    closeColumnMenu();
                } else {
                    // If click was inside menu, re-add listener (because of {once: true})
                     // Or better: don't use {once:true} and remove listener explicitly in closeColumnMenu
                     // Let's stick with the current logic for now, but it's less robust.
                }
            };

            const handleMenuKeyDown = (event) => {
                 if (!currentMenu) return;
                 if (event.key === 'Escape') {
                     closeColumnMenu();
                     // Optionally return focus to the menu button
                     // event.target.closest('.column__actions').querySelector('.action-btn--menu').focus();
                 }
                 // Add arrow key navigation if desired
            };

            // --- Export ---
            const exportColumnToText = (columnId) => {
                const tasksToExport = appData.tasks.filter(task => task.columnId === columnId)
                                            .sort((a, b) => (new Date(a.dueDate || '9999-12-31')) - (new Date(b.dueDate || '9999-12-31')));
                if (tasksToExport.length === 0) {
                    utils.showFeedback('ÎÇ¥Î≥¥ÎÇº ÏûëÏóÖÏù¥ ÏóÜÏäµÎãàÎã§.');
                    return;
                }

                const columnTitle = getColumnTitleElement(columnId)?.textContent || columnId;
                let text = `== ${columnTitle} ==\nExported on: ${new Date().toLocaleString('ko-KR')}\n\n`;
                tasksToExport.forEach(task => {
                    text += `[${task.completed ? 'x' : ' '}] ${task.title}\n`;
                    text += `   - Ï§ëÏöîÎèÑ: ${task.priority || 'Î≥¥ÌÜµ'}\n`;
                    text += `   - ÎßàÍ∞êÏùº: ${utils.formatDueDateForDisplay(task.dueDate)} (${task.dueDate || 'ÎØ∏ÏßÄÏ†ï'})\n`;
                    text += `   - Îã¥ÎãπÏûê: ${task.assignees || 'ÎØ∏ÏßÄÏ†ï'}\n`;
                    if (task.tags && task.tags.length > 0) {
                        text += `   - ÌÉúÍ∑∏: ${task.tags.join(', ')}\n`;
                    }
                    if (task.description) {
                        text += `   - ÏÑ§Î™Ö:\n     ${task.description.replace(/\n/g, '\n     ')}\n`; // Indent description lines
                    }
                    text += `\n`;
                });

                try {
                    const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const filename = columnTitle.replace(/[^a-z0-9_\-Í∞Ä-Ìû£]/gi, '_');
                    a.download = `${filename}_ÏóÖÎ¨¥Î™©Î°ù_${new Date().toISOString().split('T')[0]}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    utils.showFeedback(`${columnTitle} Î™©Î°ùÏùÑ ÌååÏùºÎ°ú ÎÇ¥Î≥¥ÎÉàÏäµÎãàÎã§.`);
                } catch(e) {
                    console.error("ÌååÏùº ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïò§Î•ò:", e);
                    utils.showFeedback("ÌååÏùº ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ï§ë Ïò§Î•ò Î∞úÏÉù", "error");
                    // Fallback: show text in a new window/tab
                    const newWindow = window.open();
                    newWindow.document.write('<pre>' + utils.escapeHtml(text) + '</pre>');
                }
            };

            // --- Search/Filter ---
            const filterTasks = (searchTerm) => {
                const term = searchTerm.toLowerCase().trim();
                const allTasks = board.querySelectorAll('.task');
                let visibleCount = 0;

                allTasks.forEach(taskEl => {
                    // Ignore placeholder during filtering
                    if (taskEl.classList.contains('task--placeholder')) return;

                    const taskId = taskEl.dataset.taskId;
                    const task = getTaskDataById(taskId);
                    let isVisible = false;

                    if (!task) {
                        isVisible = false; // Hide if task data not found
                    } else if (term === '') {
                        isVisible = true; // Show all if search is empty
                    } else {
                        // Search in title, description, assignees, tags
                        const searchableText = [
                            task.title,
                            task.description || '',
                            task.assignees || '',
                            (task.tags || []).join(' ')
                        ].join(' ').toLowerCase();
                        isVisible = searchableText.includes(term);
                    }

                    taskEl.style.display = isVisible ? '' : 'none';
                    if (isVisible) visibleCount++;
                });

                 // Optionally update column counters based on visible tasks? (Might be confusing)
                 // Update empty states based on visible tasks per column
                 appData.columns.forEach(col => {
                     const contentEl = getColumnContentElement(col.id);
                     if (contentEl) {
                         const visibleTasksInColumn = contentEl.querySelectorAll('.task:not([style*="display: none"])').length;
                         const emptyState = contentEl.querySelector('.empty-state');
                         if (visibleTasksInColumn === 0 && !emptyState && term !== '') { // Only show empty state during active search
                            const searchEmptyState = createEmptyState();
                            searchEmptyState.textContent = `'${term}' Í≤ÄÏÉâ Í≤∞Í≥º ÏóÜÏùå`;
                            contentEl.appendChild(searchEmptyState);
                         } else if ((visibleTasksInColumn > 0 || term === '') && emptyState) {
                             emptyState.remove();
                         }
                         // Restore original empty state if search is cleared and column is truly empty
                         else if (term === '' && appData.tasks.filter(t=> t.columnId === col.id).length === 0 && !emptyState) {
                              contentEl.appendChild(createEmptyState());
                         }
                     }
                 });
            };
            // Debounced version for event listener
            const debouncedFilterTasks = utils.debounce(filterTasks, DEBOUNCE_DELAY);


            // --- Form Handling ---
            const handleFormSubmit = (event) => {
                event.preventDefault();
                const formData = new FormData(taskForm);
                const taskId = formData.get('taskId');
                const taskData = {
                    columnId: formData.get('columnId'),
                    title: formData.get('taskTitle').trim(),
                    description: formData.get('taskDescription').trim(),
                    dueDate: formData.get('taskDueDate') || null, // Store as null if empty
                    assignees: formData.get('taskAssignees').trim(),
                    priority: formData.get('taskPriority'),
                    tags: [...currentTags] // Get tags from the current modal state
                };

                if (!taskData.title) {
                    utils.showFeedback('ÏóÖÎ¨¥Î™ÖÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.', 'warning');
                    taskForm.taskTitle.focus();
                    return;
                }
                // Basic date validation (optional)
                if (taskData.dueDate && isNaN(new Date(taskData.dueDate).getTime())) {
                    utils.showFeedback('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎÇ†Ïßú ÌòïÏãùÏûÖÎãàÎã§.', 'warning');
                    taskForm.taskDueDate.focus();
                    return;
                }

                if (taskId) {
                    updateTask(taskId, taskData);
                } else {
                    addTask(taskData);
                     utils.showFeedback(`'${taskData.title}' ÏóÖÎ¨¥ Ï∂îÍ∞ÄÎê®.`);
                }
                closeModal();
            };

            // --- Event Delegation Handler ---
            const handleBoardClick = (event) => {
                const target = event.target;
                const menuButton = target.closest('.action-btn--menu');
                const columnEl = target.closest('.column'); // Ïª¨Îüº ÏöîÏÜå Ï∞æÍ∏∞ (Í∏∞Ï°¥Í≥º ÎèôÏùº)

                // --- Column Actions ---
                if (columnEl) {
                    const columnId = columnEl.dataset.columnId;
                    // Add Task Button
                    if (target.matches('.action-btn--add')) {
                        openTaskModal('add', columnId);
                        return;
                    }
                    // Column Menu Button// menuButtonÏùÑ Ï∞æÏïòÎäîÏßÄ ÌôïÏù∏
                    // showColumnMenu Ìò∏Ï∂ú Ïãú event ÎåÄÏã† menuButton (ÌÅ¥Î¶≠Îêú Î≤ÑÌäº)ÏùÑ Ï†ÑÎã¨
                    if (menuButton) { 
                    showColumnMenu(menuButton, columnId); // <-- event ÎåÄÏã† menuButton Ï†ÑÎã¨
                    return; 
                    }
                    // Column Title (handled by dblclick listener on titleEl)
                }

                // --- Task Actions ---
                if (taskEl) {
                    const taskId = taskEl.dataset.taskId;
                    const actionTarget = target.closest('[data-action]');
                    const action = actionTarget?.dataset.action;

                    switch(action) {
                        case 'deleteTask':
                            const task = getTaskDataById(taskId);
                            if (task && confirm(`'${task.title}' ÏóÖÎ¨¥Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                                deleteTask(taskId);
                            }
                            break;
                        case 'toggleComplete':
                            // Ensure the click was directly on the checkbox itself
                            if (target.matches('.task__checkbox')) {
                                toggleComplete(taskId);
                            }
                            break;
                        case 'openDetail':
                             // Open detail modal when clicking title or general task area (but not checkbox/delete)
                             if (!target.matches('.task__checkbox') && !target.matches('.task__delete-btn')) {
                                 openDetailModal(taskId);
                             }
                            break;
                         // Double-click to edit is handled by a separate listener on the task element itself
                    }
                    return; // Stop further processing if a task action was handled
                }

                // --- Tag Remove Button (in Modal) ---
                 // This needs to be handled differently as it's outside the board delegate
                 // We added direct listener in renderTags
            };


            // --- Keyboard Shortcuts ---
            const handleKeyDown = (event) => {
                // Ctrl+Enter / Cmd+Enter to submit form when modal is open
                 const isModalOpen = taskModal.classList.contains('visible');
                 const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                 const modKeyPressed = isMac ? event.metaKey : event.ctrlKey;

                if (isModalOpen && modKeyPressed && event.key === 'Enter') {
                     // Check if focus is inside the textarea, if so, allow default newline behavior
                     if (document.activeElement === taskForm.taskDescription) {
                         return; // Allow newline in textarea
                     }
                    event.preventDefault(); // Prevent default newline in other inputs
                    const submitBtn = taskForm.querySelector('button[type="submit"]');
                    if (submitBtn) submitBtn.click();
                    return;
                }

                // Escape to close modals or menus
                if (event.key === 'Escape') {
                     if (currentMenu) {
                         closeColumnMenu();
                         // TODO: Return focus to menu button?
                         return;
                     }
                    if (taskModal.classList.contains('visible')) {
                         closeModal();
                         return;
                     }
                    if (detailModal.classList.contains('visible')) {
                         closeDetailModal();
                         return;
                     }
                     if (aiInterface.classList.contains('active')) {
                         aiInterface.classList.remove('active');
                         aiInterface.setAttribute('aria-hidden', 'true');
                         // TODO: Return focus to AI toggle button?
                         return;
                     }
                     // Close column title input if active
                     const activeInput = document.querySelector('.column__title-input');
                     if (activeInput) {
                         activeInput.blur(); // Trigger blur to cancel/save
                     }
                    return;
                }

                // Enter in tag input to add tag
                if (document.activeElement === tagInput && event.key === 'Enter') {
                    event.preventDefault(); // Prevent form submission
                    if (tagInput.value.trim()) {
                        addTag(tagInput.value);
                    }
                }
            };

            // --- Initialization ---
            const init = async () => {
                console.log("Initializing Task Board...");
                loadData(); // Load data and settings first
                renderBoard(); // Initial render

                // Event Listeners
                board.addEventListener('click', handleBoardClick);
                taskForm.addEventListener('submit', handleFormSubmit);
                searchInput.addEventListener('input', (e) => debouncedFilterTasks(e.target.value));
                themeToggle.addEventListener('click', toggleDarkMode);
                document.addEventListener('keydown', handleKeyDown);

                // Tab functionality (basic example)
                document.querySelectorAll('.tabs__tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        document.querySelectorAll('.tabs__tab').forEach(t => t.classList.remove('tabs__tab--active'));
                        this.classList.add('tabs__tab--active');
                        // TODO: Implement actual tab switching logic if needed
                        console.log("Tab clicked:", this.textContent);
                    });
                });

                 // Tag input listener (specific for Enter key)
                tagInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                         e.preventDefault();
                         if (tagInput.value.trim()) {
                            addTag(tagInput.value);
                         }
                    }
                });

                // --- AI Interface Listeners ---
                aiModelSelector.addEventListener('change', (e) => {
                    const selectedModel = e.target.value;
                    if (selectedModel && appData.janAI.availableModels.some(m => m.id === selectedModel)) {
                        appData.janAI.model = selectedModel;
                        console.log("AI Model changed to:", selectedModel);
                    }
                });

                toggleAI.addEventListener('click', () => {
                    const isActive = aiInterface.classList.toggle('active');
                    aiInterface.setAttribute('aria-hidden', !isActive);
                    if (isActive) {
                        aiPrompt.focus();
                    } else if (elementFocusedBeforeModal === toggleAI) {
                        // If AI button was focused before, return focus (basic check)
                        toggleAI.focus();
                    }
                });

                closeAI.addEventListener('click', () => {
                    aiInterface.classList.remove('active');
                    aiInterface.setAttribute('aria-hidden', 'true');
                     // Return focus to the toggle button
                     toggleAI.focus();
                });

                executeAI.addEventListener('click', () => {
                    processAICommand(aiPrompt.value.trim());
                    // Keep prompt value for potential retry/edit? Or clear? Let's clear.
                    // aiPrompt.value = '';
                });

                 aiPrompt.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) { // Allow Shift+Enter for newline? No, handle in main keydown.
                         e.preventDefault(); // Prevent newline
                         executeAI.click();
                    }
                });

                 aiOrganize.addEventListener('click', organizeTasksWithAI);

                // AI Suggestion Click Handler (using event delegation)
                aiSuggestions.addEventListener('click', (e) => {
                    const suggestion = e.target.closest('.ai-suggestion');
                    if (suggestion) {
                        const promptText = suggestion.dataset.prompt || suggestion.textContent;
                        aiPrompt.value = promptText;
                        aiPrompt.focus();
                        // Optionally execute immediately?
                        // executeAI.click();
                    }
                });

                // --- Final Steps ---
                await janAI.checkConnection(); // Check connection and populate models
                console.log("Task Board Initialized.");
            };

            // --- Public API ---
            return {
                init,
                // Modals are opened/closed via event handlers now, direct calls less needed
                closeModal, // Keep for buttons
                closeDetailModal, // Keep for buttons
                // addTag, // Internal now
                // removeTag // Internal now
            };

        })(utils); // Pass utils object

        // Initialize the application
        document.addEventListener('DOMContentLoaded', app.init);
    </script>
</body>
</html>